{"/simpleauthDoc/doc1/auth/annotation.html":{"title":"注解","content":" title: 注解 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 注解参数 ```java public @interface IsAuthor { //接口权限名 String value() default \"\"; //鉴权Handler的Class，默认扫描是否permissions中是否存在接口对应的value Class<? extends AutoAuthHandler>[] handler() default DefaultAuthHandler.class; //鉴权Handler链的Class Class<? extends AutoAuthHandlerChain>[] handlerChain() default DefaultAuthHandlerChain.class; } ``` ## Handler 需要继承AutoAuthHandler，如果用到Spring中的其他Bean可以使用@Component注册为Bean(推荐添加@Component注解)。 验证失败则会抛出`PermissionsException`异常 ```java public class MyAutoAuthHandler extends MyAutoAuthHandler { /** * 判断是否符合条件 * @param permission 需要的权限名 * @return 返回true则符合(放行) */ @override public boolean isAuthor(HttpServletRequest request, String permission){ //验证通过返回true放行，失败则返回false return true; } } 若没有使用@Component，首次调用Handler则通过无参构造函数创建新实例后缓存，之后的调用则会查询缓存中对应的Handler对象，可以使用`simple auth.func.handler cache true`配置关闭缓存。 ``` ## HandlerChain 需要继承AutoAuthHandlerChain，在`addChain`方法中添加Handler将多个Handler组合在一起方便模块化调用。同样的也可以选择注册为Bean ```java public abstract class AutoAuthHandlerChain { public abstract void addChain(); } ``` 常用的方法 `addLast(Class<? extends AutoAuthHandler> autoAuthHandler)`:添加Handler到尾部，参数也可以为Handler的Bean名称。 `addFirst(Class<? extends AutoAuthHandler> auto)`:添加Handler到头部"},"/simpleauthDoc/doc1/auth/interseptor.html":{"title":"SimpleAuth拦截器","content":" title: SimpleAuth拦截器 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 配置SimpleAuth拦截器 ```java //继承SimpleAuthWebConfig，可以传入Class类或Bean名 @Component public class MySimpleAuthConfig extends SimpleAuthWebConfig { @Override public void addAuthHandlers() { addAuthHandler(MyHandler.class).addPathPatterns(\"/say\"); addAuthHandlerChain(MyHandlerChain.class) .addPathPatterns(\"/user/*\") .excludePathPatterns(\"/user/vip/*\"); } } ```"},"/simpleauthDoc/doc1/auth/dynamic.html":{"title":"动态权限校验","content":" title: 动态权限校验 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 开启动态权限校验 在Application启动类上加入`@EnableDynamicAuthRequest`注解 ```java @SpringBootApplication @EnableDynamicAuthRequest public class SimpleAuthTestApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthTestApplication.class, args); } } ``` 或者在配置文件中配置 ```properties simple auth.func.dynamic auth true ``` ## 创建Provider ```java @Component public class MyAuthItemProvider implements RequestAuthItemProvider { @Override public List<RequestAuthItem> getRequestAuthItem() { List<RequestAuthItem> list new ArrayList<>(); //访问`/say`路径时使用MyHandler处理，并携带了请求权限visitor。 //注：具体请求权限的处理交给MyHandler,这里只是携带 //注：RequestAuthItem的路径也可传入List<String>，表示多个路径处理方式相同 //注：可通过数据库初始化RequestAuthItem，以动态的调整权限校验 list.add(new RequestAuthItem(\"/say\", \"visitor\", MyHandler.class)); list.add(new RequestAuthItem(MyHandlerChain.class, \"/user/*\", \"vip\")); return list; } } //处理'/say'路径的Handler @Component public class MyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { //参数name是否与permission相同。相同则放行 final String name request.getParameter(\"name\"); return name.equals(permission); } } //处理'/user/*'路径的HandlerChain @Component public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { addLast(MyHandler1.class).addLast(MyHandler2.class); } } //MyHandlerChain中的Handler @Component public class MyHandler1 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { //查询数据库添加用户permissions，为方便演示直接手动添加一个\"visitor\" ArrayList<String> permissions new ArrayList<>(); permissions.add(\"visitor\"); setPermissions(permissions); //返回true直接放行 return true; } } @Component public class MyHandler2 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final ArrayList<String> permissions getPermissions(); return !permissions.contains(permission); } } ```"},"/simpleauthDoc/doc1/limit.html":{"title":"Auth","content":" title: Auth keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## Add article limit * Create markdown file with file name end with `.md` in the directory of this file, e.g. `first.md` * Add link in `sidebar.yaml` ```markdown items: label: Brief file: README.md label: First file: first.md ``` ## More example More visit: [teedoc.neucrack.com](https://teedoc.neucrack.com/) or [teedoc.github.io](https://teedoc.github.io/) And more example see: [github.com/teedoc/teedoc.github.io](https://github.com/teedoc/teedoc.github.io) and [https://github.com/teedoc/template](https://github.com/teedoc/template) , and [sipeed wiki](https://github.com/sipeed/sipeed_wiki) ## 添加文章 * 在本文件所在目录创建 markdown 以 `.md` 结尾的文件，比如 `first.md` * 在 `sidebar.yaml` 中添加侧边栏链接 ```markdown items: label: Brief file: README.md label: First file: first.md ``` ## 更多例子 更多请访问: [teedoc.neucrack.com](https://teedoc.neucrack.com/) 或者 [teedoc.github.io](https://teedoc.github.io/) 更多例子访问: [github.com/teedoc/teedoc.github.io](https://github.com/teedoc/teedoc.github.io) 或者 [https://github.com/teedoc/template](https://github.com/teedoc/template) , 或 [sipeed wiki](https://github.com/sipeed/sipeed_wiki)"},"/simpleauthDoc/doc1/auth.html":{"title":"Auth","content":" title: Auth keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## Add article auth * Create markdown file with file name end with `.md` in the directory of this file, e.g. `first.md` * Add link in `sidebar.yaml` ```markdown items: label: Brief file: README.md label: First file: first.md ``` ## More example More visit: [teedoc.neucrack.com](https://teedoc.neucrack.com/) or [teedoc.github.io](https://teedoc.github.io/) And more example see: [github.com/teedoc/teedoc.github.io](https://github.com/teedoc/teedoc.github.io) and [https://github.com/teedoc/template](https://github.com/teedoc/template) , and [sipeed wiki](https://github.com/sipeed/sipeed_wiki) ## 添加文章 * 在本文件所在目录创建 markdown 以 `.md` 结尾的文件，比如 `first.md` * 在 `sidebar.yaml` 中添加侧边栏链接 ```markdown items: label: Brief file: README.md label: First file: first.md ``` ## 更多例子 更多请访问: [teedoc.neucrack.com](https://teedoc.neucrack.com/) 或者 [teedoc.github.io](https://teedoc.github.io/) 更多例子访问: [github.com/teedoc/teedoc.github.io](https://github.com/teedoc/teedoc.github.io) 或者 [https://github.com/teedoc/template](https://github.com/teedoc/template) , 或 [sipeed wiki](https://github.com/sipeed/sipeed_wiki)"},"/simpleauthDoc/doc1/index.html":{"title":"简介","content":" title: 简介 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 特性 这是一款基于SpringBoot的轻量化渐进式的权限校验和访问控制的框架。适用于快速构建中小型项目。上手简单 [GitHub地址](https://github.com/liuye744/SimpleAuth) ## 适用场景 * 项目复杂度不高，权限校验简单 * 鉴权方案未固定，随时可能更改 * 快速构建RBAC(基于角色的访问控制) * 限制用户访问次数 * 小粒度的访问控制 * 简单的安全防护"},"/simpleauthDoc/doc1/logging/properties.html":{"title":"日志","content":" title: 日志 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 开启鉴权模块日志 simple auth.log.limit log impl StdOut simple auth.log.log impl StdOut simple auth.log.show opt list true simple auth.func.dynamic auth true simple auth.func.dynamic limit true simple auth.func.handler cache true"},"/simpleauthDoc/doc1/logging/index.html":{"title":"日志","content":" title: 日志 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 开启鉴权模块日志 ```properties #StdOut：输出到控制台 #jdk：java自带的注解 simple auth.log.log impl StdOut ``` 配置完成项目启动后控制台将会输出： `Auth Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## 鉴权模块日志详解 ``` SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler2 \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true ``` * `uri`：请求的URI * `handlerName`：处理的Handler的全限定名 * `source`：Handler的配置方式，本例中是Dynamic Permission Configuration(通过Provider动态配置) 且本Handler在MyHandlerChain中 * `Required permission`：需要的权限名 * `Permissions to carry`：携带的权限名 * `Principal to carry`：携带的实例对象 * `Pass or not`：是否通过了 ## 开启访问控制模块日志 ```properties #StdOut：输出到控制台 #jdk：java自带的注解 simple auth.log.limit log impl StdOut #输出日志时是否带有用户的操作列表。默认为false simple auth.log.show opt list true ``` 配置完成项目启动后控制台将会输出： `Limit Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## 访问控制模块日志详解 ```properties SimpleAuth limit > \tmax times: 2 \ttime: 1 \tseconds: 60 \tban: 0 \titem: /say \tsignStrategic: com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic \tsign: 0:0:0:0:0:0:0:1 \tsource: dynamic limit \tjudgeAfterReturn: false \teffectiveStrategic: com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic \teffective: true \toptionList: [Mon Sep 11 01:13:12 CST 2023] \tPass or not: true ``` * `max times`：最大请求次数 * `time`：记录的请求次数(包括本次) * `seconds`：记录的时间 * `ban`：请求超过最大请求次数后被禁止的时间 * `item`：进行访问控制的item名，若为注解配置默认为接口名 * `sign`：用户标志。默认为用户IP，这里是本机访问所以显示为0:0:0:0:0:0:0:1 * `source`：Limit的配置来源(这里是通过Provider动态配置) * `judgeAfterReturn`：是否是在返回后判断本次请求是否被记录。为true可以通过返回值进行判断本次请求是否被记录 * `effectiveStrategic`：判断本次请求是否被记录的类 * `effective`：是否被记录了 * `optionList`：被记录的请求列表，需要在SpringBoot的配置文件中配置`simple auth.log.show opt list true`才会显示 * `Pass or not`：本次请求是否通过了 ## 自定义日志模块 实现Log接口，并添加带有一个String参数的构造函数 ```java import com.codingcube.simpleauth.logging.Log; public class MyLog implements Log { public MyLog(String clazz) { //TODO } @Override public void debug(String s) { //TODO } @Override public void error(String s, Throwable e) { //TODO } @Override public void warn(String s) { //TODO } \t//...略 } ``` 配置自己的日志模块 ```properties #参数为自定义Log的全限定名 simple auth.log.log impl com.example.simpleauthtest.domain.MyLog ```"},"/simpleauthDoc/doc1/limit/annotation.html":{"title":"注解","content":" title: 注解 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 注解参数 ```java public @interface IsLimit { //最大请求次数 int value() default 100; //记录请求的时间 int seconds() default 300; //超过限制后被禁止访问的时间 int ban() default 0; //用户标识的生成策略 Class<? extends SignStrategic> signStrategic() default DefaultSignStrategic.class; //接口的标识，每个接口对应多个用户请求记录表 String item() default \"\"; //验证本次请求是否被记录的策略 Class<? extends EffectiveStrategic> effectiveStrategic() default DefaultEffectiveStrategic.class; //是否在请求返回后判断请求是否被记录 boolean judgeAfterReturn() default true; } ``` ## 用户标识生成策略 ```java @Component public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, SimpleJoinPoint joinPoint) { return \"Sign\";//返回用户标志 } } ``` 创建自己的类继承SignStrategic，返回用户标志。若有需要可以将此类注册为Bean。 ## 验证请求记录策略 ```java @Component public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, SimpleJoinPoint joinPoint, Object result) { return true; } } ``` 当`judgeAfterReturn`参数为true时，将会在接口调用之后运行此方法，可以根据result判断此次请求是否被记录。 若`judgeAfterReturn`为false，将在接口调用之前运行，此时`result`为null。 ## ban详解 当ban等于0时，将会记录规定时间内的所有操作，下次操作发生时删除逾期记录。 当ban不为0时，请求超过最大次数后将会被记录到禁止列表，禁止时间满足取消禁止之后将删除所有请求的记录。"},"/simpleauthDoc/doc1/limit/dynamic.html":{"title":"动态访问控制","content":" title: 动态访问控制 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 开启动态访问控制 使用`@EnableDynamicLimit`注解开启动态访问控制 ```java @SpringBootApplication @EnableDynamicLimit public class SimpleAuthApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthApplication.class, args); } } ``` 或使用`simple auth.func.dynamic limit true`配置开启 ## 创建Provider ```java @Component public class MyLimitItemProvider implements RequestLimitItemProvider { @Override public List<RequestLimitItem> getRequestLimitItem() { List<RequestLimitItem> list new ArrayList<>(); //匹配路径`/say`, 60秒只能访问2次，超过则被禁止10s list.add(new RequestLimitItem(\"/say\",2,60,10)); return list; } } ``` RequestLimitItem 的参数如下 `List<String> path`:：匹配的路径 `Integer times`：最大请求次数 `Integer seconds`：记录时间 `Integer ban`：禁止时间 `Class<? extends SignStrategic> itemStrategic`：Item的生成策略 `Class<? extends SignStrategic> signStrategic`：用户标识的生成策略 `Class<? extends EffectiveStrategic> effectiveStrategic`：判断请求是否被记录的策略"},"/simpleauthDoc/doc1/start/started-limit.html":{"title":"快速上手-访问控制","content":" title: 快速上手 访问控制 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 本节中将会介绍如何通过注解限制接口访问 ## 第一步：添加Maven依赖 ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.0.0.RELEASE</version> </dependency> ``` ## 第二步：为Controller添加注解 可以为整个Controller添加，也可以为Controller中单个方法添加。访问超过限制则会抛出`AccessIsRestrictedException` ### 用例1：规定时间内限制访问次数 ```java @RestController public class MyController { @GetMapping(\"say\") //10分钟内只允许访问5次，超过之后将会被禁止10分钟 @IsLimit(value 5, seconds 600, ban 600) public String say(){ return \"Hello World\"; } } ``` ### 用例2：根据返回值确实是否记录此次操作 当返回“success”时才记录操作，返回其他内容时不记录操作，不限制访问 ```java @RestController public class MyController { @GetMapping(\"say\") @IsLimit(effectiveStrategic MyEffectiveStrategic.class) public String say(String str){ if (str.length()>3 && str.length()<12){ return \"success\"; }else { return \"fail\"; } } } public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, ProceedingJoinPoint joinPoint, Object result) { String myResult (String)result; //返回true则记录，false不记录 return \"success\".equals(myResult); } } ``` ### 用例3：同一个接口不同的参数操作记录分别计算 传递的参数不同访问限制不同(例如想要规定时间内每个资源只能点赞N次) ```java @RestController public class MyController { @GetMapping(\"say\") @IsLimit(signStrategic MySignStrategic.class) public String say(String str){ return \"Hello World\"; } } public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, ProceedingJoinPoint joinPoint) { final Object[] args joinPoint.getArgs(); final Signature signature joinPoint.getSignature(); //将参数拼接到用户sign中，保证每个用户传递不同的参数标志不相同 StringBuilder sb new StringBuilder(); sb.append(signature); for (Object arg : args) { sb.append(arg.toString()); } System.out.println(sb); return sb.toString(); } } ``` ### 用例4：自定义访问控制 ```java //全局访问控制 @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { final String addr request.getRemoteAddr(); //以用户的地址作为标志，每5分钟(300s)只允许访问2次，超过之后被禁止10分钟 //addRecord方法调用后可以访问则返回true,禁止访问返回false return LimitInfoUtil.addRecord(\"GLOBAL_ACCESS_CONTROL\", addr, 2, 300, 600); } } @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/*\"); } } ```"},"/simpleauthDoc/doc1/start/started.html":{"title":"快速上手-权限校验","content":" title: 快速上手 权限校验 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 本节中将会介绍如何通过注解进行权限校验 ## 第一步：添加maven依赖 ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.0.0.RELEASE</version> </dependency> ``` ## 第二步：添加注解 ### 用例1：通过request验证参数 创建一个类继承AutoAuthHandler，并重写IsAuthor方法 ```java public class KeyAutoAuthHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { //验证请求参数中是否携带key为114514的参数. //当然也可以进行更复杂的操作 final String key request.getParameter(\"key\"); //返回true则表示验证成功，返回false表示验证失败将会抛出PermissionsException if (\"114514\".equals(key)){ return true; } return false; } } ``` 然后将`@IsAuthor `注释添加到 Controller 或其中的方法。 ```java @Controller @IsAuthor(handler KeyAutoAuthHandler.class) public class MyController { } ``` 注: 如果你有多个` AutoAuthHandler`，你可以像这样写注释: ```java @IsAuth (handler { KeyAutoAuthHandler1.class，KeyAutoAuthHandler2.class }) ``` handler参数也可以写 Handler 的Bean 名称。这些类将按顺序执行权限检查。或者创建 继承`AutoAuthHandlerChain` 的类，并将所有 Handler 添加到该类中。 ```java public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { this.addLast(KeyAutoAuthHandler1.class) .addLast(KeyAutoAuthHandler2.class); } } //添加注解时使用 @isAuthor(handlerChain MyHandlerChain.class) ``` ### 用例2：基于角色的权限校验 ```java @RestController //添加注解到类 @IsAuthor(authentication AddPermissionKeyHandler.class) public class MyController { @IsAuthor(\"visitor\") @GetMapping(\"say\") public String say(){ return \"Hello World\"; } @IsAuthor(\"vip\") @GetMapping(\"eat\") public String eat(){ return \"eat\"; } } public class AddPermissionKeyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { ArrayList<String> permissions new ArrayList<>(); //或者查询数据库为当前请求添加角色key permissions.add(\"visitor\"); this.setPermissions(request,permissions); //查询成功，放行 return true; } } ``` 当请求`/say`时，由于注释`@IsAutor` 被添加到 MyController类上，`AddPermisonKeyHandler` 中的 `IsAuthor` 方法将首先运行。在这个方法中，字符串`visitor`被添加到用户的权限中，因此它将会验证通过并正常访问。 当请求`/eat`时，由于权限列表中没有“vip”则会请求失败，抛出`PermissionsException`异常，可以通过全局异常处理完成权限校验 ### 用例3：传递实例对象 ```java //用到的实例 public class User { String name; public User(String name) {this.name name;} public String getName() {return name;} } //接口 @RestController public class MyController { @IsAuthor(handler {MyFirstHandler.class, MySecondHandler.class}) @GetMapping(\"/say\") public String say(){ return \"Hello World\"; } } //第一个Handler public class MyFirstHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final String name request.getParameter(\"name\"); final User user new User(name); //传递实例对象 setPrincipal(user); //放行 return true; } } //第二个Handler public class MySecondHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { //获取实例对象,并验证name是否等于CodingCube final User user getPrincipal(); return \"CodingCube\".equals(user.getName()); } } ``` 当访问 `http://localhost:8080/say?name CodingCube` 时可以通过，参数name为其他时抛出`PermissionsException`异常"}}