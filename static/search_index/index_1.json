{"/simpleauthDoc/doc2/config/json.html":{"title":"JSON Configuration","content":" title: JSON Configuration keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 Recommended: Use XML Configuration ## Configure Related Configuration Files ```json { \"configs\": [ \"handler.json\", \"limit.json\", \"handlerChain.json\", \"paths.json\" ] } ``` ## Configure Handlers ```json { \"handler\": [ { \"id\": \"test\", \"class\": \"com.example.simpleauthtest.handler.MyHandler\", \"scope\": \"singleton\", \"pathsId\":\"test\" }, { \"id\": \"myHandlerId2\", \"class\": \"com.example.simpleauthtest.handler.MyHandler\", \"scope\": \"singleton\", \"paths\": { \"id\": \"myHandlerPath2\", \"path\": [ \"/say\", \"/eat\" ] } } ] } ``` ## Configure Limits ```json { \"limit\": [ { \"id\": \"limitId\", \"times\": 1, \"seconds\": 2, \"ban\": 3, \"pathsId\": \"myLimitPath\" } ] } ``` ## Configure HandlerChain ```json { \"handlerChain\": [ { \"id\": \"myHandlerChain\", \"list\": [ { \"id\": \"test\" }, { \"class\": \"com.example.simpleauthtest.handler.MyHandler\" } ], \"paths\": { \"id\": \"myPath\" } }, { \"id\": \"myHandlerChain2\", \"list\": [ { \"id\": \"test\" }, { \"class\": \"com.example.simpleauthtest.handler.MyHandler\" } ], \"paths\": { \"id\": \"myPath\" } } ] } ``` ## Configure Paths ```json { \"paths\": [ { \"id\": \"myLimitPath\", \"path\": [ \"/say\", \"/eat\", \"/sleep\" ] }, { \"id\": \"myPath\", \"path\": [ \"/say\", \"/eat\", \"/sleep\" ] } ] } ```"},"/simpleauthDoc/doc2/index.html":{"title":"Introduction","content":" title: Introduction keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Features This is a lightweight and progressive framework for permission validation and access control based on SpringBoot. It is suitable for quickly building small to medium sized projects. It's easy to get started. [GitHub Repository](https://github.com/liuye744/SimpleAuth) ## Use Cases * Low project complexity with simple permission validation * Flexible authentication solutions that may change at any time * Quick setup of RBAC (Role Based Access Control) * Complex, non intrusive parameter validation * User access rate limiting * Fine grained access control * Simple security protection"},"/simpleauthDoc/doc2/auth/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Annotation Parameters ```java public @interface SimpleAuth { // Interface permission name String value() default \"\"; // AuthHandler's Class, by default, scans whether there is an interface corresponding to 'value' in 'permissions' Class<? extends AutoAuthHandler>[] handler() default DefaultAuthHandler.class; // AuthHandlerChain's Class Class<? extends AutoAuthHandlerChain>[] handlerChain() default DefaultAuthHandlerChain.class; // Rejection strategy, the default is DefaultAuthRejectedStratagem, which throws a PermissionsException(“lack of permissions”) exception Class<? extends AuthRejectedStratagem> rejected() default NullTarget.class; } ``` ## Handler You need to extend AutoAuthHandler, and if you use other SpringBeans, you can register them as Beans (recommended to add the @Component annotation). If the validation fails, it will throw a `PermissionsException` exception. ```java public class MyAutoAuthHandler extends MyAutoAuthHandler { /** * Check if the conditions are met * @param permission The required permission name * @return Return true to allow (pass) */ @Override public boolean isAuthor(HttpServletRequest request, String permission){ // Return true for validation pass, false for failure return true; } } If you do not use @Component, the first call to the Handler will create a new instance with a parameterless constructor and cache it. Subsequent calls will query the corresponding Handler object in the cache. You can use the `simple auth.func.handler cache true` configuration to disable the cache. ``` ## HandlerChain You need to extend AutoAuthHandlerChain, and in the `addChain` function, add Handlers to combine multiple Handlers together for modularized calling. Similarly, you can choose to register them as Beans. ```java public abstract class AutoAuthHandlerChain { public abstract void addChain(); } ``` Commonly used functions `addLast(Class<? extends AutoAuthHandler> autoAuthHandler)`: Add the Handler to the end, the parameter can also be the Bean name of the Handler. `addFirst(Class<? extends AutoAuthHandler> auto)`: Add the Handler to the beginning. ## AuthRejectedStratagem By default, it throws a `PermissionsException(\"lack of permissions\")` exception. It is generally not recommended to modify this. The default rejection strategy is as follows: ```java public class DefaultAuthRejectedStratagem implements AuthRejectedStratagem { @Override public void doRejected(HttpServletRequest request, HttpServletResponse response, LogAuthFormat authFormat) { throw new PermissionsException(\"lack of permissions\"); } } ``` You can create your own class that extends the `AuthRejectedStratagem` interface and override the `doRejected` method. To use it, you can configure it through annotations: ```java // Newly created rejection strategy public class MyAuthRejectedStratagem implements AuthRejectedStratagem { @Override public void doRejected(HttpServletRequest request, HttpServletResponse response, LogAuthFormat authFormat) { throw new PermissionsException(\"this is my AuthRejectedStratagem\"); } } // Controller @GetMapping(\"/checkNameWhetherCodingCube2\") @SimpleAuth(handler MyHandler.class, rejected MyAuthRejectedStratagem.class) public String checkNameWhetherCodingCube(String name){ return \"Hello World\"; } ```"},"/simpleauthDoc/doc2/auth/interceptor.html":{"title":"SimpleAuth Interceptor","content":" title: SimpleAuth Interceptor keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Configuring the SimpleAuth Interceptor ```java // Inherit SimpleAuthWebConfig and can pass a Class or Bean name @Component public class MySimpleAuthConfig extends SimpleAuthWebConfig { @Override public void addAuthHandlers() { addAuthHandler(MyHandler.class).addPathPatterns(\"/say\"); addAuthHandlerChain(MyHandlerChain.class) .addPathPatterns(\"/user/*\") .excludePathPatterns(\"/user/vip/*\"); } } ```"},"/simpleauthDoc/doc2/auth/dynamic.html":{"title":"Dynamic Permission Validation","content":" title: Dynamic Permission Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Enabling Dynamic Permission Validation Add the `@EnableDynamicAuthRequest` annotation to your Application's startup class. ```java @SpringBootApplication @EnableDynamicAuthRequest public class SimpleAuthTestApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthTestApplication.class, args); } } ``` Alternatively, you can configure it in your application.properties file: ```properties simple auth.func.dynamic auth true ``` ## Creating a Provider ```java @Component public class MyAuthItemProvider implements RequestAuthItemProvider { @Override public List<RequestAuthItem> getRequestAuthItem() { List<RequestAuthItem> list new ArrayList<>(); // When accessing the '/say' path, use MyHandler for handling, and carry the request permission 'visitor'. // Note: The actual request permission handling is done by MyHandler; this is just for carrying the permission. // Note: You can also pass a List of Strings as paths if the handling is the same for multiple paths. // Note: You can initialize RequestAuthItem through the database to dynamically adjust permission validation. list.add(new RequestAuthItem(\"/say\", \"visitor\", MyHandler.class)); list.add(new RequestAuthItem(MyHandlerChain.class, \"/user/*\", \"vip\")); return list; } } // Handler for the '/say' path @Component public class MyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Check if the 'name' parameter is the same as the permission. If it's the same, allow access. final String name request.getParameter(\"name\"); return name.equals(permission); } } // HandlerChain for the '/user/*' path @Component public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { addLast(MyHandler1.class).addLast(MyHandler2.class); } } // Handlers in MyHandlerChain @Component public class MyHandler1 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Query the database to add user permissions. For demonstration purposes, we manually add 'visitor'. ArrayList<String> permissions new ArrayList<>(); permissions.add(\"visitor\"); setPermissions(permissions); // Return true to allow access return true; } } @Component public class MyHandler2 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final ArrayList<String> permissions getPermissions(); return !permissions.contains(permission); } } ```"},"/simpleauthDoc/doc2/start/started-validate.html":{"title":"Quick Start - Parameter Validation","content":" title: Quick Start Parameter Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to validate parameters using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.7.RELEASE</version> </dependency> ``` ## Step 2: Create Validation Class and Method The method return value must be Boolean, and there must be exactly one object to be validated as a parameter. ```java // Example object used public class User { String name; Integer age; String phone; // Omitting getter, setter, etc. } // Requirement: Validate that the age (age) is between 1 99 and the length of the nickname (name) is 5 16 public class MyValidateObj { public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } final int nameLength user.getName().length(); if (nameLength < 5 nameLength > 16){ return false; } return true; } } ``` ## Step 3: Add Annotations to Controller Add to an individual function in the Controller. If the validation fails, a `ValidateException` will be thrown. ```java // Controller object, where methods is the function name in MyValidateObj @RestController public class MyController { @GetMapping(\"/say\") @SimpleValidate(value MyValidateObj.class, methods {\"fillUser\"}) public String say(User user){ System.out.println(\"Controller \"+user); return user.getName(); } } ``` ## Other Examples ### Use Case 1: Multiple Functions in the Same Controller Performing the Same Validation `/say` needs to validate the name and age fields. `/eat` only needs to validate whether the phone field is a valid mobile number. ```java @RestController @SimpleValidate(value MyValidateObj.class) public class MyController { @GetMapping(\"/say\") @SimpleValidate(methods {\"fillUser\"}) public String say(User user){ System.out.println(\"say\"); return user.getName(); } @GetMapping(\"/eat\") @SimpleValidate(methods {\"partUser\"}) public String eat(User user){ System.out.println(\"eat\"); return user.getName(); } } // Validation class public class MyValidateObj { public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } final int nameLength user.getName().length(); if (nameLength < 5 nameLength > 16){ return false; } return true; } public Boolean partUser(User user){ final String phone user.getPhone(); // Check if it is empty, if empty return false for validation failure if (phone null){ return false; } // Regular expression to validate if the phone number is legal Pattern pattern Pattern.compile(\"^(13[0 9]14[01456879]15[0 35 9]16[2567]17[0 8]18[0 9]19[0 35 9])\\\\d{8}$\"); return pattern.matcher(phone).matches(); } } ``` ### Use Case 2: Simplifying the Validation Process with Utility Classes This part achieves the same functionality as Use Case 1. ```java public class MyValidateObj { public Boolean fillUser(User user){ // The notFalse function takes multiple boolean values, and returns false if any of them are false. // The lengthRange function validates whether the string length is between 5 16 (inclusive). // The range function validates whether the number is between 1 99 (inclusive). return SVU.notFalse( SVU.lengthRange( user.getName(), 5, 16), SVU.range( user.getAge(), 1, 99) ); } public Boolean partUser(User user){ // Regular expression validation for phone matching the regular expression. // The Regex class provides a large number of commonly used regular expression string constants. return SVU.pattern(user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); } } ``` ### Use Case 3: Throwing Different Exceptions on Validation Failure This part achieves the same functionality as the previous example. ```java // After validation fails, a ValidateException will be thrown, and the input prompt message will be carried in the exception object's message. public class MyValidateObj { public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(\"The nickname length needs to be between 5 16\", user.getName(), 5, 16), SVU.range(\"The age needs to be between 1 99\", user.getAge(), 1, 99) ); } public Boolean partUser(User user){ return SVU.pattern(\"Invalid mobile phone number format\", user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); } } // It is recommended to catch ValidateException in Advice and handle it. @ControllerAdvice public class MyExceptionHandler { @ExceptionHandler(value ValidateException.class) @ResponseBody public String exceptionHandler(ValidateException e){ return e.getMessage(); } } ``` With the above code, when accessing `http://localhost:8080/say?name CodingCube`, it will return `The age needs to be between 1 99`."},"/simpleauthDoc/doc2/validate/util.html":{"title":"Quick Start - Parameter Validation","content":" title: Quick Start Parameter Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission verification and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to simplify parameter validation using utility functions. ## Common Validation Functions The utility class for validation is named `SVU` (SimpleValidateUtils). Here are some of the commonly used validation functions provided by `SVU`: ```java // Checks if any of the provided arguments are null. Returns false if any argument is null. public static boolean notNull(Object ...args); // Checks if 'base' is within the range defined by 'start' and 'end' (inclusive). Returns true if it's within the range. public static boolean range(Integer base, Integer start, Integer end); // Checks if the length of 'content' is within the range defined by 'start' and 'end' (inclusive). Returns true if it's within the range. public static boolean lengthRange(String content, Integer start, Integer end); // Checks if 'content' matches the regular expression 'regex'. Returns true if it matches the regex. public static boolean pattern(String content, String regex); // Returns false if any of the provided boolean values is false. public static boolean notFalse(boolean ...args); ``` ## Multi Parameter Validation You can use the `notFalse` function to chain multiple validation conditions. If any of the conditions return `false`, the entire validation will fail. For example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(user.getName(), 5, 16), SVU.range(user.getAge(), 1, 99) ); } ``` ## Shortcut for Throwing Exceptions Most functions in the `SVU` class have an overloaded version that includes a message parameter. Instead of returning `false` when validation fails, these functions throw a `ValidateException` with the provided message. This allows you to handle validation failures with more informative error messages. For example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(\"Name length should be between 5 and 16\", user.getName(), 5, 16), SVU.range(\"Age must be between 1 and 99\", user.getAge(), 1, 99) ); } ``` You can catch the `ValidateException` and handle the validation message in a global exception handler: ```java @ControllerAdvice public class MyExceptionHandler { @ExceptionHandler(value ValidateException.class) @ResponseBody public String exceptionHandler(ValidateException e){ return e.getMessage(); } } ``` ## Use Delay Functions for Improved Efficiency Using the `notFalse` function as shown earlier computes all the validation conditions even if one of them returns `false`. To improve efficiency, you can use the `Delay` functions provided by `SVU`. The `notFalse` function has an overloaded version that accepts `BooleanCompute` objects. The `Delay` functions return a `BooleanCompute` object, encapsulating the validation condition, and delays its execution until necessary. Here's an example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRangeDelay(user.getName(), 5, 16), SVU.rangeDelay(user.getAge(), 1, 99) ); } ``` In this example, if the first `lengthRangeDelay` function returns `false`, the second `rangeDelay` function won't be executed, resulting in improved efficiency. ## Optional Parameter Validation If some parameters need to be validated only when they are not null, you can use the `SVOU` class (SimpleValidateOptionalUtil). The functions in `SVOU` have the same names as those in `SVU`, but they return true when the parameter is null. Here's an example where the phone number is an optional parameter, and validation is required only when it's not null: ```java public Boolean fillUser(User user){ // The Regex class provides commonly used regular expressions. SVOU.pattern(user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); return SVU.notFalse( SVU.lengthRangeDelay(user.getName(), 5, 16), SVU.rangeDelay(user.getAge(), 1, 99) ); } ``` This code will only validate the phone number if it's not null."},"/simpleauthDoc/doc2/limit/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Annotation Parameters ```java public @interface SimpleLimit { // Maximum number of requests int value() default 100; // Record the time of requests int seconds() default 300; // Time after which access is prohibited after exceeding the limit int ban() default 0; // User identification generation strategy Class<? extends SignStrategic> signStrategic() default DefaultSignStrategic.class; // Interface identifier, each interface corresponds to multiple user request records String item() default \"\"; // Strategy to verify whether this request is recorded Class<? extends EffectiveStrategic> effectiveStrategic() default DefaultEffectiveStrategic.class; // Whether to check if the request is recorded after the response boolean judgeAfterReturn() default true; // Rate limiting algorithm Class<? extends TokenLimit> tokenLimit() default CompleteLimit.class; // The default rejection strategy throws an exception Class<? extends RejectedStratagem> rejected() default NullTarget.class; } ``` ## User Identification Generation Strategy ```java @Component public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, SimpleJoinPoint joinPoint) { return \"Sign\"; // Return the user identifier } } ``` Create your own class that extends SignStrategic and return the user identifier. You can register this class as a Bean if needed. ## Request Record Verification Strategy ```java @Component public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, SimpleJoinPoint joinPoint, Object result) { return true; } } ``` When the `judgeAfterReturn` parameter is true, this function will run after the interface call, and you can determine whether the request is recorded based on the `result`. If `judgeAfterReturn` is false, it will run before the interface call, and `result` will be null. ## Explanation of 'ban' When 'ban' is set to 0, all actions within the specified time will be recorded, and expired records will be deleted when the next action occurs. When 'ban' is not 0, requests exceeding the maximum limit will be recorded in the ban list, and all request records will be deleted after the ban period ends. ## Custom Token Limit Algorithm The default algorithm records all operations precisely and is represented by `CompleteLimit`. You can also use the token bucket algorithm `TokenBucket`. You can specify the default rate limiting algorithm globally by adding the configuration `simple auth.func.limit plan tokenbucket`, or you can implement the `TokenLimit` interface yourself. ```java public interface TokenLimit { /** * Try to acquire, return whether the operation can be successful. */ boolean tryAcquire(); /** * Initialize* * @param limit The limit of the number of times to limit * @param seconds The unit time of restriction */ void init(Integer limit, Integer seconds); /** * init * * @param capacity The capacity of the limit (the number of times to limit) * @param fillRate The rate of addition */ void init(int capacity, double fillRate); /** * Remove the last operation record */ void removeFirst(); /** * The number of requests that can still be made */ int size(); /** * The number of recorded requested operations */ int optSize(); /** * The maximum number of requests */ int maxOptSize(); /** * Update synchronization information */ void sync(); /** * Get synchronization lock */ Object getSyncMutex(); } ``` After implementing the interface, you can specify it globally through configuration: `simple auth.func.limit plan {full qualified class name}`, or you can add it to specific Controllers using annotations."},"/simpleauthDoc/doc2/limit/dynamic.html":{"title":"Dynamic Access Control","content":" title: Dynamic Access Control keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Enabling Dynamic Access Control Use the `@EnableDynamicLimit` annotation to enable dynamic access control. ```java @SpringBootApplication @EnableDynamicLimit public class SimpleAuthApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthApplication.class, args); } } ``` Alternatively, you can enable it with the `simple auth.func.dynamic limit true` configuration. ## Creating a Provider ```java @Component public class MyLimitItemProvider implements RequestLimitItemProvider { @Override public List<RequestLimitItem> getRequestLimitItem() { List<RequestLimitItem> list new ArrayList<>(); // Match the path '/say', allow only 2 requests within 60 seconds, and ban for 10 seconds if exceeded. list.add(new RequestLimitItem(\"/say\", 2, 60, 10)); return list; } } ``` The parameters for `RequestLimitItem` are as follows: `List<String> path`: The matched path. `Integer times`: The maximum number of requests. `Integer seconds`: The recording time. `Integer ban`: The ban time. `Class<? extends SignStrategic> itemStrategic`: The item generation strategy, default is uri. `Class<? extends SignStrategic> signStrategic`: The user identification generation strategy, default is user IP. `Class<? extends EffectiveStrategic> effectiveStrategic`: The strategy to determine if the request is recorded, default is true. `Class<? extends TokenLimit> tokenLimit`: The rate limiting algorithm, default is CompleteLimit, which records all requests accurately."},"/simpleauthDoc/doc2/config/xml.html":{"title":"XML Configuration","content":" title: XML Configuration keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 ## Configure Related Configuration Files The default configuration file is `simpleauth.xml` in the classpath. You can add other configuration files as follows: ```xml <simpleauth> \t<configs> \t\t<config>handler.xml</config> \t\t<config>limit.xml</config> \t\t<config>paths.xml</config> \t\t<config>handlerChain.xml</config> \t</configs> </simpleauth> ``` ## Configure Handlers You can specify `id` for paths and declare specific paths separately. The `scope` is set to `singleton` by default, meaning that all functions that use this Handler will share the same instance. ```xml <simpleauth> <handler id \"test\"> <class>com.example.simpleauthtest.handler.MyHandler</class> <scope>singleton</scope> <paths id \"myHandlerPath\"/> </handler> <handler id \"myHandler2\"> <class>com.codingcube.simpleauth.security.handler.session.SessionMigratorHandler</class> <paths id \"myHandlerPath3\"> <path>/say/*</path> <path>/eat</path> </paths> </handler> </simpleauth> ``` ## Configure Limits Allow only two requests within 60 seconds, and block access for 60 seconds if the limit is exceeded. ```xml <simpleauth> <! Register Limit > <limit id \"MyLimit\"> <times>2</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> </simpleauth> ``` You can provide more detailed configuration as shown below: ```xml <simpleauth> <! Register Limit > <limit name \"MyLimit\" id \"MyLimit\"> <times>1</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <signStrategic>com.codingcube.simpleauth.auth.strategic.DefaultItemStrategic</signStrategic> <itemStrategic>com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic</itemStrategic> <effectiveStrategic>com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic</effectiveStrategic> <tokenLimit>com.codingcube.simpleauth.limit.util.TokenBucket</tokenLimit> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> </simpleauth> ``` ## Configure Handler Chains ```xml <simpleauth> <handlerChain id \"MyLimit\"> \t\t<list> \t\t\t<handler id \"test\"/> \t\t\t<handler> \t\t\t\t<class>com.example.simpleauthtest.handler.MyHandler2</class> \t\t\t</handler> \t\t</list> \t\t<paths id \"myPath\"/> </handlerChain> </simpleauth> ``` ## Configure Paths ```xml <simpleauth> <paths id \"myPath\"> <permission>myPath</permission> <path>/say/*</path> <path>/eat</path> </paths> <paths id \"myHandlerPath2\"> <path>/sleep</path> <path>/eat</path> </paths> </simpleauth> ``` ## Summary Of course, you can also configure everything in `simpleauth.xml`: ```xml <simpleauth> \t<configs> <! If the file extension is XML, you can omit the extension in the configuration file > \t\t<config>handler</config> \t\t<config>limit</config> \t\t<config>paths</config> \t\t<config>handlerChain</config> \t</configs> <handler id \"test\"> <class>com.example.simpleauthtest.handler.MyHandler</class> <scope>singleton</scope> <paths id \"myHandlerPath\"/> </handler> <limit id \"MyLimit\"> <times>1</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> <handlerChain id \"MyLimit\"> \t\t<list> \t\t\t<handler id \"test\"/> \t\t\t<handler> \t\t\t\t<class>com.example.simpleauthtest.handler.MyHandler2</class> \t\t\t</handler > \t\t</list> \t\t<paths id \"myPath\"/> </handlerChain> <paths id \"myPath\"> <permission>myPath</permission> <path>/say/*</path> <path>/eat</path> </paths> <paths id \"myHandlerPath2\"> <path>/say/*</path> <path>/eat</path> </paths> </simpleauth> ```"},"/simpleauthDoc/doc2/start/started-limit.html":{"title":"Quick Start - Access Control","content":" title: Quick Start Access Control keywords: keyword1, keyword2 desc: This is a lightweight permission verification and access control framework based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter This section will introduce how to restrict interface access through annotations and learn related parameters for more precise control. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.7.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations to Controller Annotations can be added to the entire Controller or to individual functions within the Controller. If the access exceeds the limit, an `AccessIsRestrictedException` will be thrown. ```java @RestController public class MyController { @GetMapping(\"say\") // Allow only 5 accesses within 10 minutes, after which access will be forbidden for 10 minutes @SimpleLimit(value 5, seconds 600, ban 600) public String say(){ return \"Hello World\"; } } ``` ## Other Examples ### Use Case 1: Determine Whether to Record the Operation Based on the Return Value Record the operation only when \"success\" is returned; do not record the operation when other content is returned, and do not restrict access. ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(effectiveStrategic MyEffectiveStrategic.class) public String say(String str){ if (str.length()>3 && str.length()<12){ return \"success\"; }else { return \"fail\"; } } } public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, ProceedingJoinPoint joinPoint, Object result) { String myResult (String)result; // Return true to record, false not to record return \"success\".equals(myResult); } } ``` ### Use Case 2: Different Operation Records for the Same Interface with Different Parameters Different access restrictions for different parameters passed (for example, wanting to restrict each resource to be liked only N times within a specified time period). ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(signStrategic MySignStrategic.class) public String say(String str){ return \"Hello World\"; } } public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, ProceedingJoinPoint joinPoint) { final Object[] args joinPoint.getArgs(); final Signature signature joinPoint.getSignature(); // Append the parameters to the user's sign to ensure that each user has a different sign for different parameters StringBuilder sb new StringBuilder(); sb.append(signature); for (Object arg : args) { sb.append(arg.toString()); } System.out.println(sb); return sb.toString(); } } ``` Or you can use the predefined `DiffParameterSign` strategy to achieve the same effect. ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(signStrategic DiffParameterSign.class) public String say(String str){ return \"Hello World\"; } } ``` ### Use Case 3: Custom Access Control ```java // Global access control @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { final String addr request.getRemoteAddr(); // Use the user's address as the identifier, allowing only 2 accesses every 5 minutes (300s), after which access is forbidden for 10 minutes // The addRecord function returns true if access is allowed after the call, and false if access is forbidden return LimitInfoUtil.addRecord(\"GLOBAL_ACCESS_CONTROL\", addr, 2, 300, 600); } } @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/*\"); } } ```"},"/simpleauthDoc/doc2/start/started.html":{"title":"Quick Start - Permission Verification","content":" title: Quick Start Permission Verification keywords: keyword1, keyword2 desc: This is a lightweight permission verification and access control framework based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will introduce how to perform permission verification through annotations. The first case is to verify whether the request parameters contain a parameter with the key '114514'. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.7.RELEASE</version> </dependency> ``` ## Step 2: Create Handler Create a class that extends `AutoAuthHandler` and override the `isAuthor` function. ```java public class KeyAutoAuthHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Verify if the request parameter carries a parameter with the key '114514'. // More complex operations can also be performed here. final String key request.getParameter(\"key\"); // Return true if the verification is successful, false if the verification fails, which will throw a PermissionsException. return \"114514\".equals(key); } } ``` ## Step 3: Add Annotations Next, add the `@SimpleAuth` annotation to the Controller or its functions. If added to a class, the Handler will be executed before all methods in the class. ```java @Controller @SimpleAuth(handler KeyAutoAuthHandler.class) public class MyController { } ``` If added to a method, the Handler will be executed before the method. ```java @RestController public class MyController { @SimpleAuth(handler AddPermissionKeyHandler.class) @GetMapping(\"say\") public String say(){ return \"Hello World\"; } } ``` Note: If you have multiple `AutoAuthHandler`, you can write the annotation like this: ```java @SimpleAuth(handler { KeyAutoAuthHandler1.class, KeyAutoAuthHandler2.class }) ``` The handler parameter can also be the Bean name of the Handler. These classes will perform permission checks in sequence. Alternatively, create a class that inherits `AutoAuthHandlerChain` and add all Handlers to this class. ```java public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { this.addLast(KeyAutoAuthHandler1.class) .addLast(KeyAutoAuthHandler2.class); } } // Use @SimpleAuth(handlerChain MyHandlerChain.class) when adding the annotation. ``` ## Other Cases ### Use Case 1: Role Based Permission Verification ```java @RestController // Add annotation to the class @SimpleAuth(authentication AddPermissionKeyHandler.class) public class MyController { @SimpleAuth(\"visitor\") @GetMapping(\"say\") public String say(){ return \"Hello World\"; } @SimpleAuth(\"vip\") @GetMapping(\"eat\") public String eat(){ return \"eat\"; } } public class AddPermissionKeyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { ArrayList<String> permissions new ArrayList<>(); // Or query the database to add a role key for the current request permissions.add(\"visitor\"); this.setPermissions(request,permissions); // If the query is successful, allow it to pass return true; } } ``` When requesting `/say`, since the `@SimpleAuth` annotation is added to the MyController class, the `SimpleAuth` function in `AddPermisonKeyHandler` will run first. In this function, the string `visitor` is added to the user’s permissions, so it will pass the verification and access normally. When requesting `/eat`, since “vip” is not in the permission list, the request will fail, throwing a `PermissionsException` exception, which can be handled by global exception handling to complete the permission verification. ### Use Case 2: Passing Instance Objects ```java // Instance used public class User { String name; public User(String name) {this.name name;} public String getName() {return name;} } // Interface @RestController public class MyController { @SimpleAuth(handler {MyFirstHandler.class, MySecondHandler.class}) @GetMapping(\"/say\") public String say(){ return \"Hello World\"; } } // First Handler public class MyFirstHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final String name request.getParameter(\"name\"); final User user new User(name); // Pass the instance object setPrincipal(user); // Allow to pass return true; } } // Second Handler public class MySecondHandler extends AutoAuthHandler { @Override public boolean is(HttpServletRequest request, String permission) { // Get the instance object and verify if name equals CodingCube final User user getPrincipal(); return \"CodingCube\".equals(user.getName()); } } ``` When accessing `http://localhost:8080/say?name CodingCube`, it will pass. If the parameter name is other than CodingCube, a `PermissionsException` exception will be thrown."},"/simpleauthDoc/doc2/logging/index.html":{"title":"Logging","content":" title: Logging keywords: keyword1, keyword2 desc: This is a lightweight permission verification and access control framework based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Permission Verification Module Logging ### Enable Authentication Module Logging ```properties # StdOut: Output to the console # jdk: Annotations provided by Java itself simple auth.log.log impl StdOut ``` After the configuration is complete and the project is started, the console will output: `Auth Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ### Authentication Module Logging Explanation ```java SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler2 \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true ``` * `uri`: The requested URI * `handlerName`: The fully qualified name of the handler processing the request * `source`: The configuration method of the handler, in this case, it is Dynamic Permission Configuration (configured dynamically through a Provider) and the handler is in MyHandlerChain * `Required permission`: The name of the required permission * `Permissions to carry`: The name of the permissions being carried * `Principal to carry`: The instance object being carried * `Pass or not`: Whether the request passed the authentication ## Access Control Module Logging ### Enable Access Control Module Logging ```properties # StdOut: Output to the console # jdk: Annotations provided by Java itself simple auth.log.limit log impl StdOut # Whether to include the user's operation list in the log output. Default is false simple auth.log.show opt list true ``` After the configuration is complete and the project is started, the console will output: `Limit Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ### Access Control Module Logging Explanation ```java SimpleAuth limit > \tmax times: 2 \ttime: 1 \tseconds: 60 \tban: 0 \titem: /say \tsignStrategic: com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic \tsign: 0:0:0:0:0:0:0:1 \tsource: dynamic limit \tjudgeAfterReturn: false \teffectiveStrategic: com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic \teffective: true \toptionList: [Mon Sep 11 01:13:12 CST 2023] \tPass or not: true ``` * `max times`: The maximum number of requests allowed * `time`: The number of recorded requests (including the current one) * `seconds`: The duration for which the requests are recorded * `ban`: The time period during which access is forbidden after exceeding the maximum number of requests * `item`: The name of the item subject to access control; if configured via annotation, it defaults to the interface name * `sign`: The user identifier. By default, it is the user’s IP address; in this case, it shows `0:0:0:0:0:0:0:1` because it’s a local access * `source`: The source of the Limit configuration (configured dynamically via a Provider in this case) * `judgeAfterReturn`: Whether the decision to record the request is made after the response is returned. If set to `true`, the decision to record the request can be based on the return value * `effectiveStrategic`: The class that determines whether the current request should be recorded * * `effective`: Whether the request was recorded * `optionList`: The list of recorded requests. This is displayed only when `simple auth.log.show opt list true` is set in the SpringBoot configuration file * `Pass or not`: Whether the current request passed the access control check ## Parameter Validation Module Logging ### Enable Parameter Validation Module Logging ```properties # StdOut: Output to the console # jdk: Annotations provided by Java itself simple auth.log.validated log impl StdOut ``` ### Parameter Validation Module Logging Explanation ```java SimpleAuth validate > \tvalidateObj: class com.codingcube.simpleauthtest.cache.MyValidate \tvalidateTarget: class java.lang.String \tpass or not: false ``` * `validateObj`: The validation class * `validateTarget`: The type of the target being validated * `pass or not`: Whether the current request passed the validation ## Custom Logging Module Implement the Log interface, and add a constructor with a single String parameter. ```java import com.codingcube.simpleauth.logging.Log; public class MyLog implements Log { public MyLog(String clazz) { // TODO } @Override public void debug(String s) { // TODO } @Override public void error(String s, Throwable e) { // TODO } @Override public void warn(String s) { // TODO } // ... other methods } ``` Configure your custom logging module. ```java # The parameter is the fully qualified name of the custom Log simple auth.log.log impl com.example.simpleauthtest.domain.MyLog ```"},"/simpleauthDoc/doc2/logging/properties.html":{"title":"Common Configuration Parameters","content":" title: Common Configuration Parameters keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Common Configuration Parameters ```properties # Rate limiting log, default is NoLogging (no log). # StdOut: Log to the console; jdk: Java's built in logging system simple auth.log.limit log impl StdOut # Permission validation log, default is NoLogging simple auth.log.log impl StdOut # Whether to display the user operation list in the permission validation log, default is false simple auth.log.show opt list true # Enable dynamic permission validation, default is false simple auth.func.dynamic auth true # Enable dynamic access control, default is false simple auth.func.dynamic limit true # Handler caching, default is true simple auth.func.handler cache true # Default rate limiting algorithm, default is CompleteLimit, which accurately records all operations simple auth.func.limit plan tokenBucket ```"},"/simpleauthDoc/doc2/validate/annotation.html":{"title":"Quick Start - Permission Verification","content":" title: Quick Start Permission Verification keywords: keyword1, keyword2 desc: This is a lightweight framework for permission verification and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to perform permission verification using annotations. ## Annotations ```java @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface SimpleValidate { // The class to be used for validation. The validation functions within this class must return a Boolean. Class<?> value() default Object.class; // Names of the validation functions to be used. String[] methods() default {\"validate\"}; // Strategy to handle validation rejection (default strategy throws ValidateException). Class<? extends ValidateRejectedStratagem> rejected() default DefaultValidateRejectedStratagem.class; } ``` ## Annotation Usage The `SimpleValidate` annotation is used to specify the validation class and method for permission validation. The class provided in the `value` parameter contains validation methods that must return a `Boolean` and take the object to be validated as a parameter. For example, a validation method in the validation class might look like this: ```java public class MyValidateObj { // Validate that the user's age is between 1 and 99 public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } return true; } } ``` To use the `SimpleValidate` annotation in a controller, add it to a method: ```java @RestController public class MyController { @GetMapping(\"/say\") @SimpleValidate(value MyValidateObj.class, methods {\"fillUser\"}) public String say(User user){ return user.getName(); } } ``` If multiple methods in a controller need to use the same validation class, you can specify the validation class at the class level and reference it in the method level annotations. When the class level annotation specifies a validation class, you can skip the `value` parameter in the method level annotations: ```java @RestController @SimpleValidate(value MyValidateObj.class) public class MyController { @GetMapping(\"/say\") @SimpleValidate(methods {\"fillUser\"}) public String say(User user){ System.out.println(\"say\"); return user.getName(); } @GetMapping(\"/eat\") @SimpleValidate(methods {\"partUser\"}) public String eat(User user){ System.out.println(\"eat\"); return user.getName(); } } ``` ### Rejection Strategy The default rejection strategy is to throw a `ValidateException`. You can create a custom rejection strategy by implementing the `ValidateRejectedStratagem` interface: ```java public class MyRejected implements ValidateRejectedStratagem { @Override public void doRejected(HttpServletRequest request, HttpServletResponse response, Object validationObj) { } } ``` When a validation method returns `false`, the `doRejected` function of the rejection strategy will be invoked, and the `validationObj` parameter will contain the object that was just validated. For example, when the validation of a `User` object returns `false`, the `validationObj` parameter in `doRejected` will be the `User` object."}}