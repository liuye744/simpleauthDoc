{"/simpleauthDoc/doc2/limit/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Annotation Parameters ```java public @interface SimpleLimit { // Maximum number of requests int value() default 100; // Record the time of requests int seconds() default 300; // Time after which access is prohibited after exceeding the limit int ban() default 0; // User identification generation strategy Class<? extends SignStrategic> signStrategic() default DefaultSignStrategic.class; // Interface identifier, each interface corresponds to multiple user request records String item() default \"\"; // Strategy to verify whether this request is recorded Class<? extends EffectiveStrategic> effectiveStrategic() default DefaultEffectiveStrategic.class; // Whether to check if the request is recorded after the response boolean judgeAfterReturn() default true; // Rate limiting algorithm Class<? extends TokenLimit> tokenLimit() default CompleteLimit.class; } ``` ## User Identification Generation Strategy ```java @Component public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, SimpleJoinPoint joinPoint) { return \"Sign\"; // Return the user identifier } } ``` Create your own class that extends SignStrategic and return the user identifier. You can register this class as a Bean if needed. ## Request Record Verification Strategy ```java @Component public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, SimpleJoinPoint joinPoint, Object result) { return true; } } ``` When the `judgeAfterReturn` parameter is true, this function will run after the interface call, and you can determine whether the request is recorded based on the `result`. If `judgeAfterReturn` is false, it will run before the interface call, and `result` will be null. ## Explanation of 'ban' When 'ban' is set to 0, all actions within the specified time will be recorded, and expired records will be deleted when the next action occurs. When 'ban' is not 0, requests exceeding the maximum limit will be recorded in the ban list, and all request records will be deleted after the ban period ends. ## Custom Token Limit Algorithm The default algorithm records all operations precisely and is represented by `CompleteLimit`. You can also use the token bucket algorithm `TokenBucket`. You can specify the default rate limiting algorithm globally by adding the configuration `simple auth.func.limit plan tokenbucket`, or you can implement the `TokenLimit` interface yourself. ```java public interface TokenLimit { /** * Try to acquire, return whether the operation can be successful. */ boolean tryAcquire(); /** * Initialize* * @param limit The limit of the number of times to limit * @param seconds The unit time of restriction */ void init(Integer limit, Integer seconds); /** * init * * @param capacity The capacity of the limit (the number of times to limit) * @param fillRate The rate of addition */ void init(int capacity, double fillRate); /** * Remove the last operation record */ void removeFirst(); /** * The number of requests that can still be made */ int size(); /** * The number of recorded requested operations */ int optSize(); /** * The maximum number of requests */ int maxOptSize(); /** * Update synchronization information */ void sync(); /** * Get synchronization lock */ Object getSyncMutex(); } ``` After implementing the interface, you can specify it globally through configuration: `simple auth.func.limit plan {full qualified class name}`, or you can add it to specific Controllers using annotations."},"/simpleauthDoc/doc2/config/xml.html":{"title":"XML Configuration","content":" title: XML Configuration keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 ## Configure Related Configuration Files The default configuration file is `simpleauth.xml` in the classpath. You can add other configuration files as follows: ```xml <simpleauth> \t<configs> \t\t<config>handler.xml</config> \t\t<config>limit.xml</config> \t\t<config>paths.xml</config> \t\t<config>handlerChain.xml</config> \t</configs> </simpleauth> ``` ## Configure Handlers You can specify `id` for paths and declare specific paths separately. The `scope` is set to `singleton` by default, meaning that all functions that use this Handler will share the same instance. ```xml <simpleauth> <handler id \"test\"> <class>com.example.simpleauthtest.handler.MyHandler</class> <scope>singleton</scope> <paths id \"myHandlerPath\"/> </handler> <handler id \"myHandler2\"> <class>com.codingcube.simpleauth.security.handler.session.SessionMigratorHandler</class> <paths id \"myHandlerPath3\"> <path>/say/*</path> <path>/eat</path> </paths> </handler> </simpleauth> ``` ## Configure Limits Allow only two requests within 60 seconds, and block access for 60 seconds if the limit is exceeded. ```xml <simpleauth> <! Register Limit > <limit id \"MyLimit\"> <times>2</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> </simpleauth> ``` You can provide more detailed configuration as shown below: ```xml <simpleauth> <! Register Limit > <limit name \"MyLimit\" id \"MyLimit\"> <times>1</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <signStrategic>com.codingcube.simpleauth.auth.strategic.DefaultItemStrategic</signStrategic> <itemStrategic>com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic</itemStrategic> <effectiveStrategic>com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic</effectiveStrategic> <tokenLimit>com.codingcube.simpleauth.limit.util.TokenBucket</tokenLimit> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> </simpleauth> ``` ## Configure Handler Chains ```xml <simpleauth> <handlerChain id \"MyLimit\"> \t\t<list> \t\t\t<handler id \"test\"/> \t\t\t<handler> \t\t\t\t<class>com.example.simpleauthtest.handler.MyHandler2</class> \t\t\t</handler> \t\t</list> \t\t<paths id \"myPath\"/> </handlerChain> </simpleauth> ``` ## Configure Paths ```xml <simpleauth> <paths id \"myPath\"> <permission>myPath</permission> <path>/say/*</path> <path>/eat</path> </paths> <paths id \"myHandlerPath2\"> <path>/sleep</path> <path>/eat</path> </paths> </simpleauth> ``` ## Summary Of course, you can also configure everything in `simpleauth.xml`: ```xml <simpleauth> \t<configs> <! If the file extension is XML, you can omit the extension in the configuration file > \t\t<config>handler</config> \t\t<config>limit</config> \t\t<config>paths</config> \t\t<config>handlerChain</config> \t</configs> <handler id \"test\"> <class>com.example.simpleauthtest.handler.MyHandler</class> <scope>singleton</scope> <paths id \"myHandlerPath\"/> </handler> <limit id \"MyLimit\"> <times>1</times> \t\t<seconds>60</seconds> \t\t<ban>60</ban> <paths id \"myLimitPath\"> <path>/say</path> <path>/eat</path> </paths> </limit> <handlerChain id \"MyLimit\"> \t\t<list> \t\t\t<handler id \"test\"/> \t\t\t<handler> \t\t\t\t<class>com.example.simpleauthtest.handler.MyHandler2</class> \t\t\t</handler > \t\t</list> \t\t<paths id \"myPath\"/> </handlerChain> <paths id \"myPath\"> <permission>myPath</permission> <path>/say/*</path> <path>/eat</path> </paths> <paths id \"myHandlerPath2\"> <path>/say/*</path> <path>/eat</path> </paths> </simpleauth> ```"},"/simpleauthDoc/doc2/auth/interceptor.html":{"title":"SimpleAuth Interceptor","content":" title: SimpleAuth Interceptor keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Configuring the SimpleAuth Interceptor ```java // Inherit SimpleAuthWebConfig and can pass a Class or Bean name @Component public class MySimpleAuthConfig extends SimpleAuthWebConfig { @Override public void addAuthHandlers() { addAuthHandler(MyHandler.class).addPathPatterns(\"/say\"); addAuthHandlerChain(MyHandlerChain.class) .addPathPatterns(\"/user/*\") .excludePathPatterns(\"/user/vip/*\"); } } ```"},"/simpleauthDoc/doc2/auth/dynamic.html":{"title":"Dynamic Permission Validation","content":" title: Dynamic Permission Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Enabling Dynamic Permission Validation Add the `@EnableDynamicAuthRequest` annotation to your Application's startup class. ```java @SpringBootApplication @EnableDynamicAuthRequest public class SimpleAuthTestApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthTestApplication.class, args); } } ``` Alternatively, you can configure it in your application.properties file: ```properties simple auth.func.dynamic auth true ``` ## Creating a Provider ```java @Component public class MyAuthItemProvider implements RequestAuthItemProvider { @Override public List<RequestAuthItem> getRequestAuthItem() { List<RequestAuthItem> list new ArrayList<>(); // When accessing the '/say' path, use MyHandler for handling, and carry the request permission 'visitor'. // Note: The actual request permission handling is done by MyHandler; this is just for carrying the permission. // Note: You can also pass a List of Strings as paths if the handling is the same for multiple paths. // Note: You can initialize RequestAuthItem through the database to dynamically adjust permission validation. list.add(new RequestAuthItem(\"/say\", \"visitor\", MyHandler.class)); list.add(new RequestAuthItem(MyHandlerChain.class, \"/user/*\", \"vip\")); return list; } } // Handler for the '/say' path @Component public class MyHandler extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { // Check if the 'name' parameter is the same as the permission. If it's the same, allow access. final String name request.getParameter(\"name\"); return name.equals(permission); } } // HandlerChain for the '/user/*' path @Component public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { addLast(MyHandler1.class).addLast(MyHandler2.class); } } // Handlers in MyHandlerChain @Component public class MyHandler1 extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { // Query the database to add user permissions. For demonstration purposes, we manually add 'visitor'. ArrayList<String> permissions new ArrayList<>(); permissions.add(\"visitor\"); setPermissions(permissions); // Return true to allow access return true; } } @Component public class MyHandler2 extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { final ArrayList<String> permissions getPermissions(); return !permissions.contains(permission); } } ```"},"/simpleauthDoc/doc2/auth/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Annotation Parameters ```java public @interface SimpleAuthor { // Interface permission name String value() default \"\"; // AuthHandler's Class, by default, scans whether there is an interface corresponding to 'value' in 'permissions' Class<? extends AutoAuthHandler>[] handler() default DefaultAuthHandler.class; // AuthHandlerChain's Class Class<? extends AutoAuthHandlerChain>[] handlerChain() default DefaultAuthHandlerChain.class; } ``` ## Handler You need to extend AutoAuthHandler, and if you use other SpringBeans, you can register them as Beans (recommended to add the @Component annotation). If the validation fails, it will throw a `PermissionsException` exception. ```java public class MyAutoAuthHandler extends MyAutoAuthHandler { /** * Check if the conditions are met * @param permission The required permission name * @return Return true to allow (pass) */ @Override public boolean SimpleAuthor(HttpServletRequest request, String permission){ // Return true for validation pass, false for failure return true; } } If you do not use @Component, the first call to the Handler will create a new instance with a parameterless constructor and cache it. Subsequent calls will query the corresponding Handler object in the cache. You can use the `simple auth.func.handler cache true` configuration to disable the cache. ``` ## HandlerChain You need to extend AutoAuthHandlerChain, and in the `addChain` function, add Handlers to combine multiple Handlers together for modularized calling. Similarly, you can choose to register them as Beans. ```java public abstract class AutoAuthHandlerChain { public abstract void addChain(); } ``` Commonly used functions `addLast(Class<? extends AutoAuthHandler> autoAuthHandler)`: Add the Handler to the end, the parameter can also be the Bean name of the Handler. `addFirst(Class<? extends AutoAuthHandler> auto)`: Add the Handler to the beginning."},"/simpleauthDoc/doc2/limit/dynamic.html":{"title":"Dynamic Access Control","content":" title: Dynamic Access Control keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Enabling Dynamic Access Control Use the `@EnableDynamicLimit` annotation to enable dynamic access control. ```java @SpringBootApplication @EnableDynamicLimit public class SimpleAuthApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthApplication.class, args); } } ``` Alternatively, you can enable it with the `simple auth.func.dynamic limit true` configuration. ## Creating a Provider ```java @Component public class MyLimitItemProvider implements RequestLimitItemProvider { @Override public List<RequestLimitItem> getRequestLimitItem() { List<RequestLimitItem> list new ArrayList<>(); // Match the path '/say', allow only 2 requests within 60 seconds, and ban for 10 seconds if exceeded. list.add(new RequestLimitItem(\"/say\", 2, 60, 10)); return list; } } ``` The parameters for `RequestLimitItem` are as follows: `List<String> path`: The matched path. `Integer times`: The maximum number of requests. `Integer seconds`: The recording time. `Integer ban`: The ban time. `Class<? extends SignStrategic> itemStrategic`: The item generation strategy, default is uri. `Class<? extends SignStrategic> signStrategic`: The user identification generation strategy, default is user IP. `Class<? extends EffectiveStrategic> effectiveStrategic`: The strategy to determine if the request is recorded, default is true. `Class<? extends TokenLimit> tokenLimit`: The rate limiting algorithm, default is CompleteLimit, which records all requests accurately."},"/simpleauthDoc/doc2/index.html":{"title":"Introduction","content":" title: Introduction keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Features This is a lightweight and progressive framework for permission validation and access control based on SpringBoot. It is suitable for quickly building small to medium sized projects. It's easy to get started. [GitHub Repository](https://github.com/liuye744/SimpleAuth) ## Use Cases * Low project complexity with simple permission validation * Flexible authentication solutions that may change at any time * Quick setup of RBAC (Role Based Access Control) * Complex, non intrusive parameter validation * User access rate limiting * Fine grained access control * Simple security protection"},"/simpleauthDoc/doc2/validate/util.html":{"title":"Quick Start - Parameter Validation","content":" title: Quick Start Parameter Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission verification and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to simplify parameter validation using utility functions. ## Common Validation Functions The utility class for validation is named `SVU` (SimpleValidateUtils). Here are some of the commonly used validation functions provided by `SVU`: ```java // Checks if any of the provided arguments are null. Returns false if any argument is null. public static boolean notNull(Object ...args); // Checks if 'base' is within the range defined by 'start' and 'end' (inclusive). Returns true if it's within the range. public static boolean range(Integer base, Integer start, Integer end); // Checks if the length of 'content' is within the range defined by 'start' and 'end' (inclusive). Returns true if it's within the range. public static boolean lengthRange(String content, Integer start, Integer end); // Checks if 'content' matches the regular expression 'regex'. Returns true if it matches the regex. public static boolean pattern(String content, String regex); // Returns false if any of the provided boolean values is false. public static boolean notFalse(boolean ...args); ``` ## Multi Parameter Validation You can use the `notFalse` function to chain multiple validation conditions. If any of the conditions return `false`, the entire validation will fail. For example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(user.getName(), 5, 16), SVU.range(user.getAge(), 1, 99) ); } ``` ## Shortcut for Throwing Exceptions Most functions in the `SVU` class have an overloaded version that includes a message parameter. Instead of returning `false` when validation fails, these functions throw a `ValidateException` with the provided message. This allows you to handle validation failures with more informative error messages. For example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(\"Name length should be between 5 and 16\", user.getName(), 5, 16), SVU.range(\"Age must be between 1 and 99\", user.getAge(), 1, 99) ); } ``` You can catch the `ValidateException` and handle the validation message in a global exception handler: ```java @ControllerAdvice public class MyExceptionHandler { @ExceptionHandler(value ValidateException.class) @ResponseBody public String exceptionHandler(ValidateException e){ return e.getMessage(); } } ``` ## Use Delay Functions for Improved Efficiency Using the `notFalse` function as shown earlier computes all the validation conditions even if one of them returns `false`. To improve efficiency, you can use the `Delay` functions provided by `SVU`. The `notFalse` function has an overloaded version that accepts `BooleanCompute` objects. The `Delay` functions return a `BooleanCompute` object, encapsulating the validation condition, and delays its execution until necessary. Here's an example: ```java public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRangeDelay(user.getName(), 5, 16), SVU.rangeDelay(user.getAge(), 1, 99) ); } ``` In this example, if the first `lengthRangeDelay` function returns `false`, the second `rangeDelay` function won't be executed, resulting in improved efficiency. ## Optional Parameter Validation If some parameters need to be validated only when they are not null, you can use the `SVOU` class (SimpleValidateOptionalUtil). The functions in `SVOU` have the same names as those in `SVU`, but they return true when the parameter is null. Here's an example where the phone number is an optional parameter, and validation is required only when it's not null: ```java public Boolean fillUser(User user){ // The Regex class provides commonly used regular expressions. SVOU.pattern(user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); return SVU.notFalse( SVU.lengthRangeDelay(user.getName(), 5, 16), SVU.rangeDelay(user.getAge(), 1, 99) ); } ``` This code will only validate the phone number if it's not null."},"/simpleauthDoc/doc2/validate/annotation.html":{"title":"Quick Start - Permission Verification","content":" title: Quick Start Permission Verification keywords: keyword1, keyword2 desc: This is a lightweight framework for permission verification and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to perform permission verification using annotations. ## Annotations ```java @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface SimpleValidate { // The class to be used for validation. The validation functions within this class must return a Boolean. Class<?> value() default Object.class; // Names of the validation functions to be used. String[] methods() default {\"validate\"}; // Strategy to handle validation rejection (default strategy throws ValidateException). Class<? extends ValidateRejectedStratagem> rejected() default DefaultValidateRejectedStratagem.class; } ``` ## Annotation Usage The `SimpleValidate` annotation is used to specify the validation class and method for permission validation. The class provided in the `value` parameter contains validation methods that must return a `Boolean` and take the object to be validated as a parameter. For example, a validation method in the validation class might look like this: ```java public class MyValidateObj { // Validate that the user's age is between 1 and 99 public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } return true; } } ``` To use the `SimpleValidate` annotation in a controller, add it to a method: ```java @RestController public class MyController { @GetMapping(\"/say\") @SimpleValidate(value MyValidateObj.class, methods {\"fillUser\"}) public String say(User user){ return user.getName(); } } ``` If multiple methods in a controller need to use the same validation class, you can specify the validation class at the class level and reference it in the method level annotations. When the class level annotation specifies a validation class, you can skip the `value` parameter in the method level annotations: ```java @RestController @SimpleValidate(value MyValidateObj.class) public class MyController { @GetMapping(\"/say\") @SimpleValidate(methods {\"fillUser\"}) public String say(User user){ System.out.println(\"say\"); return user.getName(); } @GetMapping(\"/eat\") @SimpleValidate(methods {\"partUser\"}) public String eat(User user){ System.out.println(\"eat\"); return user.getName(); } } ``` ### Rejection Strategy The default rejection strategy is to throw a `ValidateException`. You can create a custom rejection strategy by implementing the `ValidateRejectedStratagem` interface: ```java public class MyRejected implements ValidateRejectedStratagem { @Override public void doRejected(HttpServletRequest request, HttpServletResponse response, Object validationObj) { } } ``` When a validation method returns `false`, the `doRejected` function of the rejection strategy will be invoked, and the `validationObj` parameter will contain the object that was just validated. For example, when the validation of a `User` object returns `false`, the `validationObj` parameter in `doRejected` will be the `User` object."},"/simpleauthDoc/doc2/config/json.html":{"title":"JSON Configuration","content":" title: JSON Configuration keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 Recommended: Use XML Configuration ## Configure Related Configuration Files ```json { \"configs\": [ \"handler.json\", \"limit.json\", \"handlerChain.json\", \"paths.json\" ] } ``` ## Configure Handlers ```json { \"handler\": [ { \"id\": \"test\", \"class\": \"com.example.simpleauthtest.handler.MyHandler\", \"scope\": \"singleton\", \"pathsId\":\"test\" }, { \"id\": \"myHandlerId2\", \"class\": \"com.example.simpleauthtest.handler.MyHandler\", \"scope\": \"singleton\", \"paths\": { \"id\": \"myHandlerPath2\", \"path\": [ \"/say\", \"/eat\" ] } } ] } ``` ## Configure Limits ```json { \"limit\": [ { \"id\": \"limitId\", \"times\": 1, \"seconds\": 2, \"ban\": 3, \"pathsId\": \"myLimitPath\" } ] } ``` ## Configure HandlerChain ```json { \"handlerChain\": [ { \"id\": \"myHandlerChain\", \"list\": [ { \"id\": \"test\" }, { \"class\": \"com.example.simpleauthtest.handler.MyHandler\" } ], \"paths\": { \"id\": \"myPath\" } }, { \"id\": \"myHandlerChain2\", \"list\": [ { \"id\": \"test\" }, { \"class\": \"com.example.simpleauthtest.handler.MyHandler\" } ], \"paths\": { \"id\": \"myPath\" } } ] } ``` ## Configure Paths ```json { \"paths\": [ { \"id\": \"myLimitPath\", \"path\": [ \"/say\", \"/eat\", \"/sleep\" ] }, { \"id\": \"myPath\", \"path\": [ \"/say\", \"/eat\", \"/sleep\" ] } ] } ```"},"/simpleauthDoc/doc2/logging/index.html":{"title":"Logging","content":" title: Logging keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Enabling Authentication Module Logging ```properties # StdOut: Log to the console # jdk: Java's built in logging system simple auth.log.log impl StdOut ``` After configuring, the console will output the following message when the project starts: `Auth Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## Explanation of Authentication Module Logging ``` SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler2 \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true ``` `uri`: The request's URI. `handlerName`: The full class name of the handler being used. `source`: The configuration source of the handler. In this example, it's \"Dynamic Permission Configuration\" (configured dynamically through a Provider), and the handler is part of the \"MyHandlerChain.\" `Required permission`: The required permission name. `Permissions to carry`: The carried permission names. `Principal to carry`: The carried instance object. `Pass or not`: Whether it passed. ## Enabling Access Control Module Logging ```properties # StdOut: Log to the console # jdk: Java's built in logging system simple auth.log.limit log impl StdOut # Whether to include the user's operation list in the log. Default is false. simple auth.log.show opt list true ``` After configuring, the console will output the following message when the project starts: `Limit Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## Explanation of Access Control Module Logging ```properties SimpleAuth limit > \tmax times: 2 \ttime: 1 \tseconds: 60 \tban: 0 \titem: /say \tsignStrategic: com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic \tsign: 0:0:0:0:0:0:0:1 \tsource: dynamic limit \tjudgeAfterReturn: false \teffectiveStrategic: com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic \teffective: true \toptionList: [Mon Sep 11 01:13:12 CST 2023] \tPass or not: true ``` `max times`: Maximum number of requests. `time`: Recorded requests (including the current one). `seconds`: Recording time. `ban`: Time the request is banned after exceeding the maximum number of requests. `item`: The name of the item for access control. By default, it's the interface name if configured using annotations. `sign`: User identifier. By default, it's the user's IP. In this example, it shows as \"0:0:0:0:0:0:0:1\" because it's local access. `source`: The source of the limit's configuration (configured dynamically through a Provider). `judgeAfterReturn`: Whether to determine if the current request is recorded after returning. When set to true, you can determine if the request is recorded based on the return value. `effectiveStrategic`: The class used to determine if the request is recorded. `effective`: Whether it's recorded. `optionList`: The list of recorded requests. It's shown when configured in the SpringBoot properties file with `simple auth.log.show opt list true`. `Pass or not`: Whether the current request passed. ## Custom Logging Module Implement the `Log` interface and add a constructor with a `String` parameter. ```java import com.codingcube.simpleauth.logging.Log; public class MyLog implements Log { public MyLog(String clazz) { //TODO } @Override public void debug(String s) { //TODO } @Override public void error(String s, Throwable e) { //TODO } @Override public void warn(String s) { //TODO } // ... and so on } ``` Configure your custom logging module in the properties file. ```properties # Parameter is the full qualified name of your custom Log class simple auth.log.log impl com.example.simpleauthtest.domain.MyLog ```"},"/simpleauthDoc/doc2/logging/properties.html":{"title":"Common Configuration Parameters","content":" title: Common Configuration Parameters keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter ## Common Configuration Parameters ```properties # Rate limiting log, default is NoLogging (no log). # StdOut: Log to the console; jdk: Java's built in logging system simple auth.log.limit log impl StdOut # Permission validation log, default is NoLogging simple auth.log.log impl StdOut # Whether to display the user operation list in the permission validation log, default is false simple auth.log.show opt list true # Enable dynamic permission validation, default is false simple auth.func.dynamic auth true # Enable dynamic access control, default is false simple auth.func.dynamic limit true # Handler caching, default is true simple auth.func.handler cache true # Default rate limiting algorithm, default is CompleteLimit, which accurately records all operations simple auth.func.limit plan tokenBucket ```"},"/simpleauthDoc/doc2/start/started-limit.html":{"title":"Quick Start - Access Control","content":" title: Quick Start Access Control keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to restrict access to interfaces using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.3.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations You can add the annotations to the entire Controller or individual functions within the Controller. Exceeding the access limits will result in an `AccessIsRestrictedException`. ### Use Case 1: Limiting Access Count Within a Specified Time ```java @RestController public class MyController { @GetMapping(\"say\") // Allow only 5 accesses within 10 minutes, and restrict access for 10 minutes if the limit is exceeded. @SimpleLimit(value 5, seconds 600, ban 600) public String say(){ return \"Hello World\"; } } ``` ### Use Case 2: Determining Whether to Record an Operation Based on the Return Value Record an operation only when the return value is \"success,\" and do not record when the return value is different. There are no access restrictions in this case. ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(effectiveStrategic MyEffectiveStrategic.class) public String say(String str){ if (str.length() > 3 && str.length() < 12){ return \"success\"; } else { return \"fail\"; } } } public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, ProceedingJoinPoint joinPoint, Object result) { String myResult (String)result; // Return true to record the operation, false to not record it return \"success\".equals(myResult); } } ``` ### Use Case 3: Recording Different Operations Separately with Different Parameters Different parameters lead to different access restrictions. For example, you may want to limit the number of likes for each resource within a specific time frame. ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(signStrategic MySignStrategic.class) public String say(String str){ return \"Hello World\"; } } public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, ProceedingJoinPoint joinPoint) { final Object[] args joinPoint.getArgs(); final Signature signature joinPoint.getSignature(); // Concatenate the parameters with the user's sign to ensure a different parameter flag for each user StringBuilder sb new StringBuilder(); sb.append(signature); for (Object arg : args) { sb.append(arg.toString()); } System.out.println(sb); return sb.toString(); } } ``` You can also use the built in `DiffParameterSign` strategy to achieve the same effect. ```java @RestController public class MyController { @GetMapping(\"say\") @SimpleLimit(signStrategic DiffParameterSign.class) public String say(String str){ return \"Hello World\"; } } ``` ### Use Case 4: Custom Access Control Global access control can be implemented using an `HandlerInterceptor`. In this example, access is restricted to 2 times every 5 minutes (300 seconds) for a user based on their IP address. If a user exceeds the limit, access is restricted for 10 minutes (600 seconds). ```java // Global access control @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { final String addr request.getRemoteAddr(); // Allow only 2 accesses every 5 minutes (300s) for each user, and restrict access for 10 minutes (600s) if the limit is exceeded. // Return true if `addRecord` allows access, and false if access is restricted. return LimitInfoUtil.addRecord(\"GLOBAL_ACCESS_CONTROL\", addr, 2, 300, 600); } } @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/*\"); } } ```"},"/simpleauthDoc/doc2/start/started.html":{"title":"Quick Start - Permission Validation","content":" title: Quick Start Permission Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to perform permission validation using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.3.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations ### Use Case 1: Validating Parameters through Request Create a class that extends `AutoAuthHandler` and override the `SimpleAuthor` function. ```java public class KeyAutoAuthHandler extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { // Validate whether the request parameters include a key with the value \"114514\". final String key request.getParameter(\"key\"); // Return true if the validation succeeds, and false if it fails, which will throw a PermissionsException. if (\"114514\".equals(key)){ return true; } return false; } } ``` Then, add the `@SimpleAuthor` annotation to your Controller or its methods. ```java @Controller @SimpleAuthor(handler KeyAutoAuthHandler.class) public class MyController { } ``` Note: If you have multiple `AutoAuthHandler`s, you can use the annotation as follows: ```java @SimpleAuthor(handler {KeyAutoAuthHandler1.class, KeyAutoAuthHandler2.class}) ``` You can also create a class that extends `AutoAuthHandlerChain` and add all the handlers to it. ```java public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { this.addLast(KeyAutoAuthHandler1.class) .addLast(KeyAutoAuthHandler2.class); } } ``` And then, add the annotation as `@SimpleAuthor(handlerChain MyHandlerChain.class)`. ### Use Case 2: Role Based Permission Validation ```java @RestController // Add the annotation to the class @SimpleAuthor(authentication AddPermissionKeyHandler.class) public class MyController { @SimpleAuthor(\"visitor\") @GetMapping(\"say\") public String say(){ return \"Hello World\"; } @SimpleAuthor(\"vip\") @GetMapping(\"eat\") public String eat(){ return \"eat\"; } } public class AddPermissionKeyHandler extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { ArrayList<String> permissions new ArrayList<>(); // Or query the database to add the role key for the current request permissions.add(\"visitor\"); this.setPermissions(request,permissions); // Verification successful, allow access return true; } } ``` When a request is made to `/say`, the `SimpleAuthor` function in `AddPermissionKeyHandler` will run first because the `@IsAuthor` annotation is added to the `MyController` class. In this function, the string \"visitor\" is added to the user's permissions, allowing access. When a request is made to `/eat`, it will fail because \"vip\" is not in the list of permissions, and a `PermissionsException` will be thrown. You can handle permission validation using a global exception handler. ### Use Case 3: Passing Instance Objects ```java // User instance public class User { String name; public User(String name) {this.name name;} public String getName() {return name;} } // Controller @RestController public class MyController { @SimpleAuthor(handler {MyFirstHandler.class, MySecondHandler.class}) @GetMapping(\"/say\") public String say(){ return \"Hello World\"; } } // First Handler public class MyFirstHandler extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { final String name request.getParameter(\"name\"); final User user new User(name); // Pass the instance object setPrincipal(user); // Allow access return true; } } // Second Handler public class MySecondHandler extends AutoAuthHandler { @Override public boolean SimpleAuthor(HttpServletRequest request, String permission) { // Get the instance object and verify if the name is \"CodingCube\" final User user getPrincipal(); return \"CodingCube\".equals(user.getName()); } } ``` When accessing `http://localhost:8080/say?name CodingCube`, the request is allowed to pass. If the `name` parameter is different, a `PermissionsException` will be thrown."},"/simpleauthDoc/doc2/start/started-validate.html":{"title":"Quick Start - Parameter Validation","content":" title: Quick Start Parameter Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 class: heading_no_counter In this section, we will explain how to validate parameters using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.4.3.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations You can add annotations to individual functions within a Controller. If the validation limit is exceeded, a `ValidateException` will be thrown. ### Use Case 1: Simple Validation of User Name and Age Validate that the age (age) is between 1 and 99 and that the length of the nickname (name) is between 5 and 16. ```java // User class public class User { String name; Integer age; String phone; // Getters and setters omitted } // Controller where methods refer to functions in MyValidateObj @RestController public class MyController { @GetMapping(\"/say\") @SimpleValidate(value MyValidateObj.class, methods {\"fillUser\"}) public String say(User user){ System.out.println(\"Controller \" + user); return user.getName(); } } // Validation class (returns a Boolean and has exactly one object to validate as a parameter) public class MyValidateObj { public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } final int nameLength user.getName().length(); if (nameLength < 5 nameLength > 16){ return false; } return true; } } ``` ### Use Case 2: Reusing the Same Validation for Multiple Functions in the Same Controller The `/say` endpoint requires validation of the `name` and `age` fields, while the `/eat` endpoint only requires validation of the `phone` field for a valid mobile phone number. ```java @RestController @SimpleValidate(value MyValidateObj.class) public class MyController { @GetMapping(\"/say\") @SimpleValidate(methods {\"fillUser\"}) public String say(User user){ System.out.println(\"say\"); return user.getName(); } @GetMapping(\"/eat\") @SimpleValidate(methods {\"partUser\"}) public String eat(User user){ System.out.println(\"eat\"); return user.getName(); } } // Validation class public class MyValidateObj { public Boolean fillUser(User user){ final Integer age user.getAge(); if (age < 1 age > 99){ return false; } final int nameLength user.getName().length(); if (nameLength < 5 nameLength > 16){ return false; } return true; } public Boolean partUser(User user){ final String phone user.getPhone(); if (phone null){ return false; } Pattern pattern Pattern.compile(\"^(13[0 9]14[01456879]15[0 35 9]16[2567]17[0 8]18[0 9]19[0 35 9])\\\\d{8}$\"); return pattern.matcher(phone).matches(); } } ``` ### Use Case 3: Simplifying Validation Using a Utility Class This section demonstrates the same functionality as Use Case 2. ```java public class MyValidateObj { public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange( user.getName(), 5, 16), SVU.range( user.getAge(), 1, 99) ); } public Boolean partUser(User user){ return SVU.pattern(user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); } } ``` ### Use Case 4: Throwing Different Exceptions on Validation Failure This section demonstrates the same functionality as the previous example. In this case, a `ValidateException` will be thrown when validation fails, and the input message will be carried in the exception's message. ```java // The ValidateException will be thrown on validation failure, and the provided message will be carried in the exception's message. public class MyValidateObj { public Boolean fillUser(User user){ return SVU.notFalse( SVU.lengthRange(\"昵称长度需要在5 16之间\", user.getName(), 5, 16), SVU.range(\"年龄需要在1 99之间\", user.getAge(), 1, 99) ); } public Boolean partUser(User user){ return SVU.pattern(\"手机号格式不合法\", user.getPhone(), Regex.CHINESE_MOBIL_PHONE_NUMBER); } } // It's recommended to catch ValidateException in an advice class and handle it there. @ControllerAdvice public class MyExceptionHandler { @ExceptionHandler(value ValidateException.class) @ResponseBody public String exceptionHandler(ValidateException e){ return e.getMessage(); } } ``` With the provided code, accessing `http://localhost:8080/say?name CodingCube` will return the message `\"年龄需要在1 99之间\"` if validation fails."}}