{"/simpleauthDoc/doc2/logging/properties.html":{"title":"日志","content":" title: 日志 keywords: keyword1, keyword2 desc: 这是一款基于SpringBoot的轻量化的权限校验和访问控制的框架。适用于轻量级以及渐进式的项目。 date: 2023 09 10 ## 开启鉴权模块日志 simple auth.log.limit log impl StdOut simple auth.log.log impl StdOut simple auth.log.show opt list true simple auth.func.dynamic auth true simple auth.func.dynamic limit true simple auth.func.handler cache true"},"/simpleauthDoc/doc2/logging/index.html":{"title":"Logging","content":" title: Logging keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 ## Enabling Authentication Module Logging ```properties # StdOut: Output to the console # jdk: Java's built in logging simple auth.log.log impl StdOut ``` Once configured, upon project startup, the console will output: `Auth Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## Authentication Module Logging Explanation ``` SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true SimpleAuth auth > \turi: /say \thandlerName: com.example.simpleauthtest.handler.MyHandler2 \tsource: Dynamic Permission Configuration handlerChain com.example.simpleauthtest.handler.MyHandlerChain \tRequired permission: vip \tPermissions to carry: [visitor] \tPrincipal to carry: null \tPass or not: true ``` `uri`: The request's URI. `handlerName`: The fully qualified name of the handling Handler. `source`: Handler configuration method. In this example, it's \"Dynamic Permission Configuration\" (configured dynamically via a Provider) and this Handler is within the \"MyHandlerChain.\" `Required permission`: The required permission name. `Permissions to carry`: The carried permission names. `Principal to carry`: The carried instance object. `Pass or not`: Whether the request passed. ## Enabling Access Control Module Logging ```properties # StdOut: Output to the console # jdk: Java's built in logging simple auth.log.limit log impl StdOut # Whether to include the user's operation list when logging. Default is false. simple auth.log.show opt list true ``` Once configured, upon project startup, the console will output: `Limit Logging initialized using class com.codingcube.simpleauth.logging.stdout.StdOutImpl adapter.` ## Access Control Module Logging Explanation ``` SimpleAuth limit > \tmax times: 2 \ttime: 1 \tseconds: 60 \tban: 0 \titem: /say \tsignStrategic: com.codingcube.simpleauth.auth.strategic.DefaultSignStrategic \tsign: 0:0:0:0:0:0:0:1 \tsource: dynamic limit \tjudgeAfterReturn: false \teffectiveStrategic: com.codingcube.simpleauth.limit.strategic.DefaultEffectiveStrategic \teffective: true \toptionList: [Mon Sep 11 01:13:12 CST 2023] \tPass or not: true ``` `max times`: Maximum number of requests. `time`: Number of recorded requests (including the current one). `seconds`: Recording time. `ban`: Time for which the request is banned after exceeding the maximum number of requests. `item`: Name of the item for access control. Defaults to the interface name if configured via annotation. `sign`: User identifier. Defaults to the user's IP address. In this case, it's showing as 0:0:0:0:0:0:0:1, indicating localhost. `source`: Configuration source for Limit (configured dynamically via a Provider). `judgeAfterReturn`: Whether to determine if the current request is recorded after it returns. If true, you can use the return value to determine if the request is recorded. `effectiveStrategic`: Class used to determine if the current request is recorded. `effective`: Whether the request is recorded. `optionList`: List of recorded requests. Requires simple auth.log.show opt list true to be configured in the Spring Boot configuration file. `Pass or not`: Whether the current request passed. ## Custom Logging Module Implement the Log interface and add a constructor with a String parameter. ```java import com.codingcube.simpleauth.logging.Log; public class MyLog implements Log { public MyLog(String clazz) { // TODO: Implement your custom logging logic here. } @Override public void debug(String s) { // TODO: Implement debug log logic. } @Override public void error(String s, Throwable e) { // TODO: Implement error log logic. } @Override public void warn(String s) { // TODO: Implement warning log logic. } \t// ... and so on for other log levels. } ``` Configure your custom logging module. ```java # Provide the fully qualified name of your custom Log implementation. simple auth.log.log impl com.example.simpleauthtest.domain.MyLog ```"},"/simpleauthDoc/doc2/limit/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 ## Annotation Parameters ```java public @interface IsLimit { // Maximum number of requests int value() default 100; // Record the time of the request int seconds() default 300; // Time period during which access is denied after exceeding the limit int ban() default 0; // User identifier generation strategy Class<? extends SignStrategic> signStrategic() default DefaultSignStrategic.class; // Interface identifier, each interface corresponds to multiple user request records String item() default \"\"; // Strategy to verify whether this request is recorded Class<? extends EffectiveStrategic> effectiveStrategic() default DefaultEffectiveStrategic.class; // Whether to check if the request is recorded after the request returns boolean judgeAfterReturn() default true; } ``` ## User Identifier Generation Strategy ```java @Component public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, SimpleJoinPoint joinPoint) { return \"Sign\"; // Return the user identifier } } ``` Create your own class that extends SignStrategic and return the user identifier. If necessary, you can register this class as a Bean. ## Request Record Verification Strategy ```java @Component public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, SimpleJoinPoint joinPoint, Object result) { return true; } } ``` When the judgeAfterReturn parameter is set to true, this method will run after the interface call. You can determine whether the request is recorded based on the result. If judgeAfterReturn is set to false, it will run before the interface call, and result will be null. ## Explanation of 'ban' When ban is equal to 0, it will record all operations within the specified time, and expired records will be deleted when the next operation occurs. When ban is not equal to 0, requests exceeding the maximum number will be recorded in the ban list. The ban will be lifted after a certain period, and all request records will be deleted."},"/simpleauthDoc/doc2/limit/dynamic.html":{"title":"Dynamic Access Control","content":" title: Dynamic Access Control keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 ## Enabling Dynamic Access Control To enable dynamic access control, use the `@EnableDynamicLimit` annotation: ```java @SpringBootApplication @EnableDynamicLimit public class SimpleAuthApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthApplication.class, args); } } ``` Alternatively, you can enable it using configuration: ```java simple auth.func.dynamic limit true ``` ## Creating a Provider ```java @Component public class MyLimitItemProvider implements RequestLimitItemProvider { @Override public List<RequestLimitItem> getRequestLimitItem() { List<RequestLimitItem> list new ArrayList<>(); // Matching path '/say', allowed 2 requests within 60 seconds, and a ban for 10 seconds if exceeded. list.add(new RequestLimitItem(\"/say\", 2, 60, 10)); return list; } } ``` The parameters for RequestLimitItem are as follows: `List<String> path`: The matching paths. `Integer times`: Maximum number of requests. `Integer seconds`: Recording time. `Integer ban`: Ban time. `Class<? extends SignStrategic> itemStrategic`: Item generation strategy. `Class<? extends SignStrategic> signStrategic`: User identifier generation strategy. `Class<? extends EffectiveStrategic> effectiveStrategic`: Strategy to determine whether the request is recorded."},"/simpleauthDoc/doc2/start/started-limit.html":{"title":"Quick Start - Access Control","content":" title: Quick Start Access Control keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 In this section, we will learn how to restrict access to endpoints using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.1.0.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations to Controller You can add annotations to the entire Controller or to individual methods within the Controller. If access exceeds the limit, an AccessIsRestrictedException will be thrown. ### Use Case 1: Limiting Access Count Within a Specified Time Period ```java @RestController public class MyController { @GetMapping(\"say\") // Allow only 5 accesses within 10 minutes, and restrict access for 10 minutes if exceeded @IsLimit(value 5, seconds 600, ban 600) public String say(){ return \"Hello World\"; } } ``` ### Use Case 2: Determining Whether to Record the Operation Based on the Return Value In this example, we want to record the operation only when the endpoint returns \"success.\" If it returns anything else, we don't want to record the operation, and there are no access restrictions. ```java @RestController public class MyController { @GetMapping(\"say\") @IsLimit(effectiveStrategic MyEffectiveStrategic.class) public String say(String str){ if (str.length() > 3 && str.length() < 12){ return \"success\"; } else { return \"fail\"; } } } public class MyEffectiveStrategic extends EffectiveStrategic { @Override public Boolean effective(HttpServletRequest request, ProceedingJoinPoint joinPoint, Object result) { String myResult (String)result; // Return true to record the operation, or false to skip recording return \"success\".equals(myResult); } } ``` ### Use Case 3: Recording Operations with Different Access Limits Based on Different Parameters In this example, we want to apply different access limits to the same endpoint based on different parameters. For instance, we want to limit the number of \"likes\" for each resource within a specified time frame. ```java @RestController public class MyController { @GetMapping(\"say\") @IsLimit(signStrategic MySignStrategic.class) public String say(String str){ return \"Hello World\"; } } public class MySignStrategic extends SignStrategic { @Override public String sign(HttpServletRequest request, ProceedingJoinPoint joinPoint) { final Object[] args joinPoint.getArgs(); final Signature signature joinPoint.getSignature(); // Concatenate the parameters into the user's sign to ensure a unique sign for different parameter values StringBuilder sb new StringBuilder(); sb.append(signature); for (Object arg : args) { sb.append(arg.toString()); } System.out.println(sb); return sb.toString(); } } ```"},"/simpleauthDoc/doc2/start/started.html":{"title":"Quick Start - Permission Validation","content":" title: Quick Start Permission Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 In this section, we will learn how to perform permission validation using annotations. ## Step 1: Add Maven Dependency ```xml <dependency> <groupId>io.github.liuye744</groupId> <artifactId>simpleAuth spring boot starter</artifactId> <version>1.1.0.RELEASE</version> </dependency> ``` ## Step 2: Add Annotations ### Use Case 1: Validating Parameters through Request Create a class that extends `AutoAuthHandler` and override the `isAuthor` method. ```java public class KeyAutoAuthHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Verify if the request parameters contain a key parameter with the value \"114514\". // You can perform more complex operations as needed. final String key request.getParameter(\"key\"); // Return true if the validation is successful, or false to throw a PermissionsException for validation failure. if (\"114514\".equals(key)){ return true; } return false; } } ``` Then, add the @IsAuthor annotation to the Controller class or its methods. ```java @Controller @IsAuthor(handler KeyAutoAuthHandler.class) public class MyController { } ``` Note: If you have multiple AutoAuthHandler instances, you can use the annotation as follows: ``` @IsAuth(handler { KeyAutoAuthHandler1.class, KeyAutoAuthHandler2.class }) ``` The handler parameter can also specify the bean names of the handlers. These classes will execute permission checks in the specified order. Alternatively, you can create a class that extends AutoAuthHandlerChain and add all handlers to that class. ```java public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { this.addLast(KeyAutoAuthHandler1.class) .addLast(KeyAutoAuthHandler2.class); } } // When adding the annotation, use @IsAuthor(handlerChain MyHandlerChain.class) ``` ### Use Case 2: Role Based Permission Validation ```java @RestController // Add the annotation to the class @IsAuthor(authentication AddPermissionKeyHandler.class) public class MyController { @IsAuthor(\"visitor\") @GetMapping(\"say\") public String say(){ return \"Hello World\"; } @IsAuthor(\"vip\") @GetMapping(\"eat\") public String eat(){ return \"eat\"; } } public class AddPermissionKeyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { ArrayList<String> permissions new ArrayList<>(); // Alternatively, you can query a database to add the role key for the current request. permissions.add(\"visitor\"); this.setPermissions(request, permissions); // Verification successful, allow access. return true; } } ``` When a request is made to /say, the AddPermissionKeyHandler class is executed first due to the @IsAuthor annotation added to the MyController class. In this method, the string \"visitor\" is added to the user's permissions, allowing the request to pass and access the endpoint. When a request is made to /eat, the request fails because the permission list does not contain \"vip,\" resulting in a PermissionsException exception. You can handle permission validation through global exception handling. ### Use Case 3: Passing Instance Objects ```java // Class for the instance used public class User { String name; public User(String name) {this.name name;} public String getName() {return name;} } // Controller @RestController public class MyController { @IsAuthor(handler {MyFirstHandler.class, MySecondHandler.class}) @GetMapping(\"/say\") public String say(){ return \"Hello World\"; } } // First Handler public class MyFirstHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final String name request.getParameter(\"name\"); final User user new User(name); // Pass the instance object setPrincipal(user); // Allow access return true; } } // Second Handler public class MySecondHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Retrieve the instance object and verify if the name is \"CodingCube\" final User user getPrincipal(); return \"CodingCube\".equals(user.getName()); } } ``` When accessing http://localhost:8080/say?name CodingCube, the request is allowed to pass. If the name parameter is set to something other than \"CodingCube,\" a PermissionsException exception is thrown."},"/simpleauthDoc/doc2/auth/annotation.html":{"title":"Annotations","content":" title: Annotations keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 ## Annotation Parameters ```java public @interface IsAuthor { // Interface permission name String value() default \"\"; // Class of the authentication handler, default to scan if the value exists in permissions Class<? extends AutoAuthHandler>[] handler() default DefaultAuthHandler.class; // Class of the authentication handler chain Class<? extends AutoAuthHandlerChain>[] handlerChain() default DefaultAuthHandlerChain.class; } ``` ## Handler You need to extend AutoAuthHandler, and if you are using other Spring beans, you can register them as a @Component (recommended to add the @Component annotation). If the validation fails, it will throw a PermissionsException exception. ```java public class MyAutoAuthHandler extends AutoAuthHandler { /** * Check if the condition is met * @param permission Required permission name * @return Return true if it meets the condition (pass) */ @Override public boolean isAuthor(HttpServletRequest request, String permission){ // Return true to pass if validation succeeds, otherwise return false return true; } } ``` If you do not use @Component, the first call to the handler will create a new instance with a parameterless constructor and cache it. Subsequent calls will retrieve the corresponding handler object from the cache. You can use simple auth.func.handler cache true to disable the cache. ## HandlerChain You need to extend AutoAuthHandlerChain and add handlers in the addChain method to combine multiple handlers for modularized calling. Similarly, you can choose to register it as a bean. ```java public abstract class AutoAuthHandlerChain { public abstract void addChain(); } ``` Common methods: `addLast(Class<? extends AutoAuthHandler> autoAuthHandler)`: Add a handler to the end, the parameter can also be the name of the handler bean. `addFirst(Class<? extends AutoAuthHandler> auto)`: Add a handler to the beginning."},"/simpleauthDoc/doc2/auth/interseptor.html":{"title":"SimpleAuth Interceptor","content":" title: SimpleAuth Interceptor keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 ## Configuring the SimpleAuth Interceptor ```java // Extend SimpleAuthWebConfig and provide a Class or Bean name @Component public class MySimpleAuthConfig extends SimpleAuthWebConfig { @Override public void addAuthHandlers() { addAuthHandler(MyHandler.class).addPathPatterns(\"/say\"); addAuthHandlerChain(MyHandlerChain.class) .addPathPatterns(\"/user/*\") .excludePathPatterns(\"/user/vip/*\"); } }"},"/simpleauthDoc/doc2/auth/dynamic.html":{"title":"Dynamic Permission Validation","content":" title: Dynamic Permission Validation keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on Spring Boot. Suitable for lightweight and progressive projects. date: 2023 09 10 ## Enabling Dynamic Permission Validation To enable dynamic permission validation, add the `@EnableDynamicAuthRequest` annotation to your Application's startup class. ```java @SpringBootApplication @EnableDynamicAuthRequest public class SimpleAuthTestApplication { public static void main(String[] args) { SpringApplication.run(SimpleAuthTestApplication.class, args); } } ``` Alternatively, you can configure it in your properties file. ```java simple auth.func.dynamic auth true ``` ## Creating a Provider ``` @Component public class MyAuthItemProvider implements RequestAuthItemProvider { @Override public List<RequestAuthItem> getRequestAuthItem() { List<RequestAuthItem> list new ArrayList<>(); // When accessing the '/say' path, it will be handled by MyHandler with the 'visitor' permission. // Note: The specific handling of the request permission is delegated to MyHandler; here, we are only specifying it. // Note: The path in RequestAuthItem can also accept a List<String> to represent multiple paths with the same handling. // Note: You can initialize RequestAuthItem from a database to dynamically adjust permission validation. list.add(new RequestAuthItem(\"/say\", \"visitor\", MyHandler.class)); list.add(new RequestAuthItem(MyHandlerChain.class, \"/user/*\", \"vip\")); return list; } } // Handler for the '/say' path @Component public class MyHandler extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Check if the 'name' parameter is the same as the 'permission'. If they match, allow access. final String name request.getParameter(\"name\"); return name.equals(permission); } } // HandlerChain for the '/user/*' path @Component public class MyHandlerChain extends AutoAuthHandlerChain { @Override public void addChain() { addLast(MyHandler1.class).addLast(MyHandler2.class); } } // Handler within MyHandlerChain @Component public class MyHandler1 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { // Query the database to add user permissions. For demonstration purposes, we are manually adding \"visitor.\" ArrayList<String> permissions new ArrayList<>(); permissions.add(\"visitor\"); setPermissions(permissions); // Return true to allow access directly. return true; } } @Component public class MyHandler2 extends AutoAuthHandler { @Override public boolean isAuthor(HttpServletRequest request, String permission) { final ArrayList<String> permissions getPermissions(); return !permissions.contains(permission); } } ```"},"/simpleauthDoc/doc2/index.html":{"title":"Introduction","content":" title: Introduction keywords: keyword1, keyword2 desc: This is a lightweight framework for permission validation and access control based on SpringBoot. It is suitable for lightweight and progressive projects. date: 2023 09 10 ## Features This is a lightweight and progressive framework for permission validation and access control based on SpringBoot. It is suitable for quickly building small to medium sized projects. It's easy to get started with. [GitHub Repository](https://github.com/liuye744/SimpleAuth) ## Use Cases * Low project complexity with simple permission validation * Flexible authentication requirements subject to change * Quick setup for RBAC (Role Based Access Control) * Limiting user access counts * Fine grained access control * Simple security measures"}}